<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<!--
-- Copyright (c) 2020 BedRock Systems, Inc.
-- This software is distributed under the terms of the BedRock Open-Source License.
-- See the LICENSE-BedRock file in the repository root for details.
-->

<!--
-- SPDX-LIcense-Identifier:BSD-2-Clause
-->
<html xmlns="http://www.w3.org/1999/xhtml">

<head>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<link href="../css/coqdocjs/coqdoc.css" rel="stylesheet" type="text/css" />
<link href="../css/coqdocjs/coqdocjs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../js/coqdocjs/config.js"></script>
<script type="text/javascript" src="../js/coqdocjs/coqdocjs.js"></script>
</head>

<body onload="document.getElementById('content').focus()">
  <div id="header">
    <span class="left">
      <span class="modulename"> <script> document.write(document.title) </script> </span>
    </span>

    <span class="button" id="toggle-proofs"></span>

    <!-- NOTE: These are displayed right to left on the page -->
    <span class="right">
      <a href="./indexpage.html"> Index </a>
      <a href="./toc.html"> `theories/` </a>
      <a href="../../index.html"> Toplevel </a>
    </span>
</div>
    <div id="content" tabindex="-1" onblur="document.getElementById('content').focus()">
    <div id="main">
<h1 class="libtitle">bedrock.lang.cpp.logic.heap_pred.aggregate</h1>

<div class="code">
<span class="comment">(*<br/>
&nbsp;*&nbsp;Copyright&nbsp;(c)&nbsp;2023&nbsp;BedRock&nbsp;Systems,&nbsp;Inc.<br/>
&nbsp;*&nbsp;This&nbsp;software&nbsp;is&nbsp;distributed&nbsp;under&nbsp;the&nbsp;terms&nbsp;of&nbsp;the&nbsp;BedRock&nbsp;Open-Source&nbsp;License.<br/>
&nbsp;*&nbsp;See&nbsp;the&nbsp;LICENSE-BedRock&nbsp;file&nbsp;in&nbsp;the&nbsp;repository&nbsp;root&nbsp;for&nbsp;details.<br/>
&nbsp;*)</span><br/>

<br/>
<span class="id" title="keyword">Require</span> <span class="id" title="keyword">Import</span> <a class="idref" href="bedrock.lang.cpp.logic.heap_pred.prelude.html#"><span class="id" title="library">bedrock.lang.cpp.logic.heap_pred.prelude</span></a>.<br/>
<span class="id" title="keyword">From</span> <span class="id" title="var">bedrock.lang.cpp.logic.heap_pred</span> <span class="id" title="keyword">Require</span> <span class="id" title="keyword">Import</span> <a class="idref" href="bedrock.lang.cpp.logic.heap_pred.valid.html#"><span class="id" title="library">valid</span></a> <a class="idref" href="bedrock.lang.cpp.logic.heap_pred.null.html#"><span class="id" title="library">null</span></a>.<br/>

<br/>
#[<span class="id" title="var">local</span>] <span class="id" title="keyword">Set</span> <span class="id" title="keyword">Printing</span> <span class="id" title="var">Coercions</span>.<br/>
<span class="id" title="keyword">Implicit</span> <span class="id" title="keyword">Types</span> (σ : <a class="idref" href="bedrock.lang.cpp.semantics.genv.html#genv"><span class="id" title="class">genv</span></a>) (<span class="id" title="var">p</span> : <a class="idref" href="bedrock.lang.cpp.semantics.values.html#PTRS_INTF_AXIOM.ptr"><span class="id" title="axiom">ptr</span></a>) (<span class="id" title="var">o</span> : <a class="idref" href="bedrock.lang.cpp.semantics.values.html#PTRS_INTF_AXIOM.offset"><span class="id" title="axiom">offset</span></a>).<br/>

<br/>
<a id="structR_Locked" class="idref" href="#structR_Locked"><span class="id" title="axiom, definition, module"><span id="structR_Locked.body" class="id"><span id="structR_Locked.unlock" class="id"><span id="structR" class="id"><span id="structR.body" class="id"><span id="structR.unlock" class="id"><span id="structR_unlock_subterm" class="id">mlock</span></span></span></span></span></span></span></a><br/>
<a id="structR_Locked" class="idref" href="#structR_Locked"><span class="id" title="axiom, definition, module"><span id="structR_Locked.body" class="id"><span id="structR_Locked.unlock" class="id"><span id="structR" class="id"><span id="structR.body" class="id"><span id="structR.unlock" class="id"><span id="structR_unlock_subterm" class="id">Definition</span></span></span></span></span></span></span></a> <a id="structR_Locked" class="idref" href="#structR_Locked"><span class="id" title="axiom, definition, module"><span id="structR_Locked.body" class="id"><span id="structR_Locked.unlock" class="id"><span id="structR" class="id"><span id="structR.body" class="id"><span id="structR.unlock" class="id"><span id="structR_unlock_subterm" class="id">structR</span></span></span></span></span></span></span></a> <a id="structR_Locked" class="idref" href="#structR_Locked"><span class="id" title="axiom, definition, module"><span id="structR_Locked.body" class="id"><span id="structR_Locked.unlock" class="id"><span id="structR" class="id"><span id="structR.body" class="id"><span id="structR.unlock" class="id"><span id="structR_unlock_subterm" class="id">`{</span></span></span></span></span></span></span></a><a id="ebf069dbc779b42a15c441a6d39d5f83" class="idref" href="#ebf069dbc779b42a15c441a6d39d5f83"><span class="id" title="axiom, binder, definition, module"><span id="cb3edd5393c7bbdf625595792a237037" class="id"><span id="structR_Locked" class="id"><span id="structR_Locked.body" class="id"><span id="structR_Locked.unlock" class="id"><span id="structR" class="id"><span id="structR.body" class="id"><span id="structR.unlock" class="id"><span id="structR_unlock_subterm" class="id">Σ</span></span></span></span></span></span></span></span></span></a> <a id="structR_Locked" class="idref" href="#structR_Locked"><span class="id" title="axiom, definition, module"><span id="structR_Locked.body" class="id"><span id="structR_Locked.unlock" class="id"><span id="structR" class="id"><span id="structR.body" class="id"><span id="structR.unlock" class="id"><span id="structR_unlock_subterm" class="id">:</span></span></span></span></span></span></span></a> <a id="structR_Locked" class="idref" href="#structR_Locked"><span class="id" title="axiom, definition, module"><span id="structR_Locked.body" class="id"><span id="structR_Locked.unlock" class="id"><span id="structR" class="id"><span id="structR.body" class="id"><span id="structR.unlock" class="id"><span id="structR_unlock_subterm" class="id">cpp_logic</span></span></span></span></span></span></span></a><a id="structR_Locked" class="idref" href="#structR_Locked"><span class="id" title="axiom, definition, module"><span id="structR_Locked.body" class="id"><span id="structR_Locked.unlock" class="id"><span id="structR" class="id"><span id="structR.body" class="id"><span id="structR.unlock" class="id"><span id="structR_unlock_subterm" class="id">}</span></span></span></span></span></span></span></a> <a id="structR_Locked" class="idref" href="#structR_Locked"><span class="id" title="axiom, definition, module"><span id="structR_Locked.body" class="id"><span id="structR_Locked.unlock" class="id"><span id="structR" class="id"><span id="structR.body" class="id"><span id="structR.unlock" class="id"><span id="structR_unlock_subterm" class="id">{</span></span></span></span></span></span></span></a><a id="baa46ab95945e710a86e84e8dbcf8141" class="idref" href="#baa46ab95945e710a86e84e8dbcf8141"><span class="id" title="axiom, binder, definition, module"><span id="72e868d13abb05ece78ff9e6f5f88467" class="id"><span id="structR_Locked" class="id"><span id="structR_Locked.body" class="id"><span id="structR_Locked.unlock" class="id"><span id="structR" class="id"><span id="structR.body" class="id"><span id="structR.unlock" class="id"><span id="structR_unlock_subterm" class="id">σ</span></span></span></span></span></span></span></span></span></a> <a id="structR_Locked" class="idref" href="#structR_Locked"><span class="id" title="axiom, definition, module"><span id="structR_Locked.body" class="id"><span id="structR_Locked.unlock" class="id"><span id="structR" class="id"><span id="structR.body" class="id"><span id="structR.unlock" class="id"><span id="structR_unlock_subterm" class="id">:</span></span></span></span></span></span></span></a> <a id="structR_Locked" class="idref" href="#structR_Locked"><span class="id" title="axiom, definition, module"><span id="structR_Locked.body" class="id"><span id="structR_Locked.unlock" class="id"><span id="structR" class="id"><span id="structR.body" class="id"><span id="structR.unlock" class="id"><span id="structR_unlock_subterm" class="id">genv</span></span></span></span></span></span></span></a><a id="structR_Locked" class="idref" href="#structR_Locked"><span class="id" title="axiom, definition, module"><span id="structR_Locked.body" class="id"><span id="structR_Locked.unlock" class="id"><span id="structR" class="id"><span id="structR.body" class="id"><span id="structR.unlock" class="id"><span id="structR_unlock_subterm" class="id">}</span></span></span></span></span></span></span></a> <a id="structR_Locked" class="idref" href="#structR_Locked"><span class="id" title="axiom, definition, module"><span id="structR_Locked.body" class="id"><span id="structR_Locked.unlock" class="id"><span id="structR" class="id"><span id="structR.body" class="id"><span id="structR.unlock" class="id"><span id="structR_unlock_subterm" class="id">(</span></span></span></span></span></span></span></a><a id="cls:4" class="idref" href="#cls:4"><span class="id" title="axiom, binder, definition, module"><span id="cls:10" class="id"><span id="structR_Locked" class="id"><span id="structR_Locked.body" class="id"><span id="structR_Locked.unlock" class="id"><span id="structR" class="id"><span id="structR.body" class="id"><span id="structR.unlock" class="id"><span id="structR_unlock_subterm" class="id">cls</span></span></span></span></span></span></span></span></span></a> <a id="structR_Locked" class="idref" href="#structR_Locked"><span class="id" title="axiom, definition, module"><span id="structR_Locked.body" class="id"><span id="structR_Locked.unlock" class="id"><span id="structR" class="id"><span id="structR.body" class="id"><span id="structR.unlock" class="id"><span id="structR_unlock_subterm" class="id">:</span></span></span></span></span></span></span></a> <a id="structR_Locked" class="idref" href="#structR_Locked"><span class="id" title="axiom, definition, module"><span id="structR_Locked.body" class="id"><span id="structR_Locked.unlock" class="id"><span id="structR" class="id"><span id="structR.body" class="id"><span id="structR.unlock" class="id"><span id="structR_unlock_subterm" class="id">globname</span></span></span></span></span></span></span></a><a id="structR_Locked" class="idref" href="#structR_Locked"><span class="id" title="axiom, definition, module"><span id="structR_Locked.body" class="id"><span id="structR_Locked.unlock" class="id"><span id="structR" class="id"><span id="structR.body" class="id"><span id="structR.unlock" class="id"><span id="structR_unlock_subterm" class="id">)</span></span></span></span></span></span></span></a> <a id="structR_Locked" class="idref" href="#structR_Locked"><span class="id" title="axiom, definition, module"><span id="structR_Locked.body" class="id"><span id="structR_Locked.unlock" class="id"><span id="structR" class="id"><span id="structR.body" class="id"><span id="structR.unlock" class="id"><span id="structR_unlock_subterm" class="id">(</span></span></span></span></span></span></span></a><a id="q:5" class="idref" href="#q:5"><span class="id" title="axiom, binder, definition, module"><span id="q:11" class="id"><span id="structR_Locked" class="id"><span id="structR_Locked.body" class="id"><span id="structR_Locked.unlock" class="id"><span id="structR" class="id"><span id="structR.body" class="id"><span id="structR.unlock" class="id"><span id="structR_unlock_subterm" class="id">q</span></span></span></span></span></span></span></span></span></a> <a id="structR_Locked" class="idref" href="#structR_Locked"><span class="id" title="axiom, definition, module"><span id="structR_Locked.body" class="id"><span id="structR_Locked.unlock" class="id"><span id="structR" class="id"><span id="structR.body" class="id"><span id="structR.unlock" class="id"><span id="structR_unlock_subterm" class="id">:</span></span></span></span></span></span></span></a> <a id="structR_Locked" class="idref" href="#structR_Locked"><span class="id" title="axiom, definition, module"><span id="structR_Locked.body" class="id"><span id="structR_Locked.unlock" class="id"><span id="structR" class="id"><span id="structR.body" class="id"><span id="structR.unlock" class="id"><span id="structR_unlock_subterm" class="id">cQp.t</span></span></span></span></span></span></span></a><a id="structR_Locked" class="idref" href="#structR_Locked"><span class="id" title="axiom, definition, module"><span id="structR_Locked.body" class="id"><span id="structR_Locked.unlock" class="id"><span id="structR" class="id"><span id="structR.body" class="id"><span id="structR.unlock" class="id"><span id="structR_unlock_subterm" class="id">)</span></span></span></span></span></span></span></a> <a id="structR_Locked" class="idref" href="#structR_Locked"><span class="id" title="axiom, definition, module"><span id="structR_Locked.body" class="id"><span id="structR_Locked.unlock" class="id"><span id="structR" class="id"><span id="structR.body" class="id"><span id="structR.unlock" class="id"><span id="structR_unlock_subterm" class="id">:</span></span></span></span></span></span></span></a> <a id="structR_Locked" class="idref" href="#structR_Locked"><span class="id" title="axiom, definition, module"><span id="structR_Locked.body" class="id"><span id="structR_Locked.unlock" class="id"><span id="structR" class="id"><span id="structR.body" class="id"><span id="structR.unlock" class="id"><span id="structR_unlock_subterm" class="id">Rep</span></span></span></span></span></span></span></a> <a id="structR_Locked" class="idref" href="#structR_Locked"><span class="id" title="axiom, definition, module"><span id="structR_Locked.body" class="id"><span id="structR_Locked.unlock" class="id"><span id="structR" class="id"><span id="structR.body" class="id"><span id="structR.unlock" class="id"><span id="structR_unlock_subterm" class="id">:=</span></span></span></span></span></span></span></a><br/>
&nbsp;&nbsp;<a id="structR_Locked" class="idref" href="#structR_Locked"><span class="id" title="axiom, definition, module"><span id="structR_Locked.body" class="id"><span id="structR_Locked.unlock" class="id"><span id="structR" class="id"><span id="structR.body" class="id"><span id="structR.unlock" class="id"><span id="structR_unlock_subterm" class="id">as_Rep</span></span></span></span></span></span></span></a> <a id="structR_Locked" class="idref" href="#structR_Locked"><span class="id" title="axiom, definition, module"><span id="structR_Locked.body" class="id"><span id="structR_Locked.unlock" class="id"><span id="structR" class="id"><span id="structR.body" class="id"><span id="structR.unlock" class="id"><span id="structR_unlock_subterm" class="id">(</span></span></span></span></span></span></span></a><a id="structR_Locked" class="idref" href="#structR_Locked"><span class="id" title="axiom, definition, module"><span id="structR_Locked.body" class="id"><span id="structR_Locked.unlock" class="id"><span id="structR" class="id"><span id="structR.body" class="id"><span id="structR.unlock" class="id"><span id="structR_unlock_subterm" class="id">fun</span></span></span></span></span></span></span></a> <a id="p:6" class="idref" href="#p:6"><span class="id" title="axiom, binder, definition, module"><span id="structR_Locked" class="id"><span id="structR_Locked.body" class="id"><span id="structR_Locked.unlock" class="id"><span id="structR" class="id"><span id="structR.body" class="id"><span id="structR.unlock" class="id"><span id="structR_unlock_subterm" class="id">p</span></span></span></span></span></span></span></span></a> <a id="structR_Locked" class="idref" href="#structR_Locked"><span class="id" title="axiom, definition, module"><span id="structR_Locked.body" class="id"><span id="structR_Locked.unlock" class="id"><span id="structR" class="id"><span id="structR.body" class="id"><span id="structR.unlock" class="id"><span id="structR_unlock_subterm" class="id">=&gt;</span></span></span></span></span></span></span></a> <a id="structR_Locked" class="idref" href="#structR_Locked"><span class="id" title="axiom, definition, module"><span id="structR_Locked.body" class="id"><span id="structR_Locked.unlock" class="id"><span id="structR" class="id"><span id="structR.body" class="id"><span id="structR.unlock" class="id"><span id="structR_unlock_subterm" class="id">struct_padding</span></span></span></span></span></span></span></a> <a id="structR_Locked" class="idref" href="#structR_Locked"><span class="id" title="axiom, definition, module"><span id="structR_Locked.body" class="id"><span id="structR_Locked.unlock" class="id"><span id="structR" class="id"><span id="structR.body" class="id"><span id="structR.unlock" class="id"><span id="structR_unlock_subterm" class="id">p</span></span></span></span></span></span></span></a> <a id="structR_Locked" class="idref" href="#structR_Locked"><span class="id" title="axiom, definition, module"><span id="structR_Locked.body" class="id"><span id="structR_Locked.unlock" class="id"><span id="structR" class="id"><span id="structR.body" class="id"><span id="structR.unlock" class="id"><span id="structR_unlock_subterm" class="id">cls</span></span></span></span></span></span></span></a> <a id="structR_Locked" class="idref" href="#structR_Locked"><span class="id" title="axiom, definition, module"><span id="structR_Locked.body" class="id"><span id="structR_Locked.unlock" class="id"><span id="structR" class="id"><span id="structR.body" class="id"><span id="structR.unlock" class="id"><span id="structR_unlock_subterm" class="id">q</span></span></span></span></span></span></span></a><a id="structR_Locked" class="idref" href="#structR_Locked"><span class="id" title="axiom, definition, module"><span id="structR_Locked.body" class="id"><span id="structR_Locked.unlock" class="id"><span id="structR" class="id"><span id="structR.body" class="id"><span id="structR.unlock" class="id"><span id="structR_unlock_subterm" class="id">)</span></span></span></span></span></span></span></a>.<br/>
#[<span class="id" title="var">global</span>] <span class="id" title="var">Arguments</span> <a class="idref" href="bedrock.lang.cpp.logic.heap_pred.aggregate.html#body"><span class="id" title="axiom">structR</span></a> {<span class="id" title="var">_</span> <span class="id" title="var">Σ</span> σ} <span class="id" title="var">cls</span> <span class="id" title="var">q</span> : <span class="id" title="tactic">assert</span>.<br/>

<br/>
<a id="unionR_Locked" class="idref" href="#unionR_Locked"><span class="id" title="axiom, definition, module"><span id="unionR_Locked.body" class="id"><span id="unionR_Locked.unlock" class="id"><span id="unionR" class="id"><span id="unionR.body" class="id"><span id="unionR.unlock" class="id"><span id="unionR_unlock_subterm" class="id">mlock</span></span></span></span></span></span></span></a><br/>
<a id="unionR_Locked" class="idref" href="#unionR_Locked"><span class="id" title="axiom, definition, module"><span id="unionR_Locked.body" class="id"><span id="unionR_Locked.unlock" class="id"><span id="unionR" class="id"><span id="unionR.body" class="id"><span id="unionR.unlock" class="id"><span id="unionR_unlock_subterm" class="id">Definition</span></span></span></span></span></span></span></a> <a id="unionR_Locked" class="idref" href="#unionR_Locked"><span class="id" title="axiom, definition, module"><span id="unionR_Locked.body" class="id"><span id="unionR_Locked.unlock" class="id"><span id="unionR" class="id"><span id="unionR.body" class="id"><span id="unionR.unlock" class="id"><span id="unionR_unlock_subterm" class="id">unionR</span></span></span></span></span></span></span></a> <a id="unionR_Locked" class="idref" href="#unionR_Locked"><span class="id" title="axiom, definition, module"><span id="unionR_Locked.body" class="id"><span id="unionR_Locked.unlock" class="id"><span id="unionR" class="id"><span id="unionR.body" class="id"><span id="unionR.unlock" class="id"><span id="unionR_unlock_subterm" class="id">`{</span></span></span></span></span></span></span></a><a id="475f6c17bae93ed6b0d4829862030679" class="idref" href="#475f6c17bae93ed6b0d4829862030679"><span class="id" title="axiom, binder, definition, module"><span id="f8cd4500ff4fee5cd966dfeb97ee3847" class="id"><span id="unionR_Locked" class="id"><span id="unionR_Locked.body" class="id"><span id="unionR_Locked.unlock" class="id"><span id="unionR" class="id"><span id="unionR.body" class="id"><span id="unionR.unlock" class="id"><span id="unionR_unlock_subterm" class="id">Σ</span></span></span></span></span></span></span></span></span></a> <a id="unionR_Locked" class="idref" href="#unionR_Locked"><span class="id" title="axiom, definition, module"><span id="unionR_Locked.body" class="id"><span id="unionR_Locked.unlock" class="id"><span id="unionR" class="id"><span id="unionR.body" class="id"><span id="unionR.unlock" class="id"><span id="unionR_unlock_subterm" class="id">:</span></span></span></span></span></span></span></a> <a id="unionR_Locked" class="idref" href="#unionR_Locked"><span class="id" title="axiom, definition, module"><span id="unionR_Locked.body" class="id"><span id="unionR_Locked.unlock" class="id"><span id="unionR" class="id"><span id="unionR.body" class="id"><span id="unionR.unlock" class="id"><span id="unionR_unlock_subterm" class="id">cpp_logic</span></span></span></span></span></span></span></a><a id="unionR_Locked" class="idref" href="#unionR_Locked"><span class="id" title="axiom, definition, module"><span id="unionR_Locked.body" class="id"><span id="unionR_Locked.unlock" class="id"><span id="unionR" class="id"><span id="unionR.body" class="id"><span id="unionR.unlock" class="id"><span id="unionR_unlock_subterm" class="id">}</span></span></span></span></span></span></span></a> <a id="unionR_Locked" class="idref" href="#unionR_Locked"><span class="id" title="axiom, definition, module"><span id="unionR_Locked.body" class="id"><span id="unionR_Locked.unlock" class="id"><span id="unionR" class="id"><span id="unionR.body" class="id"><span id="unionR.unlock" class="id"><span id="unionR_unlock_subterm" class="id">{</span></span></span></span></span></span></span></a><a id="90e77474618ba1a451407daf80040e41" class="idref" href="#90e77474618ba1a451407daf80040e41"><span class="id" title="axiom, binder, definition, module"><span id="2cc2b4bb09eef09b11acd987eb0eb4c0" class="id"><span id="unionR_Locked" class="id"><span id="unionR_Locked.body" class="id"><span id="unionR_Locked.unlock" class="id"><span id="unionR" class="id"><span id="unionR.body" class="id"><span id="unionR.unlock" class="id"><span id="unionR_unlock_subterm" class="id">σ</span></span></span></span></span></span></span></span></span></a> <a id="unionR_Locked" class="idref" href="#unionR_Locked"><span class="id" title="axiom, definition, module"><span id="unionR_Locked.body" class="id"><span id="unionR_Locked.unlock" class="id"><span id="unionR" class="id"><span id="unionR.body" class="id"><span id="unionR.unlock" class="id"><span id="unionR_unlock_subterm" class="id">:</span></span></span></span></span></span></span></a> <a id="unionR_Locked" class="idref" href="#unionR_Locked"><span class="id" title="axiom, definition, module"><span id="unionR_Locked.body" class="id"><span id="unionR_Locked.unlock" class="id"><span id="unionR" class="id"><span id="unionR.body" class="id"><span id="unionR.unlock" class="id"><span id="unionR_unlock_subterm" class="id">genv</span></span></span></span></span></span></span></a><a id="unionR_Locked" class="idref" href="#unionR_Locked"><span class="id" title="axiom, definition, module"><span id="unionR_Locked.body" class="id"><span id="unionR_Locked.unlock" class="id"><span id="unionR" class="id"><span id="unionR.body" class="id"><span id="unionR.unlock" class="id"><span id="unionR_unlock_subterm" class="id">}</span></span></span></span></span></span></span></a> <a id="unionR_Locked" class="idref" href="#unionR_Locked"><span class="id" title="axiom, definition, module"><span id="unionR_Locked.body" class="id"><span id="unionR_Locked.unlock" class="id"><span id="unionR" class="id"><span id="unionR.body" class="id"><span id="unionR.unlock" class="id"><span id="unionR_unlock_subterm" class="id">(</span></span></span></span></span></span></span></a><a id="cls:15" class="idref" href="#cls:15"><span class="id" title="axiom, binder, definition, module"><span id="cls:22" class="id"><span id="unionR_Locked" class="id"><span id="unionR_Locked.body" class="id"><span id="unionR_Locked.unlock" class="id"><span id="unionR" class="id"><span id="unionR.body" class="id"><span id="unionR.unlock" class="id"><span id="unionR_unlock_subterm" class="id">cls</span></span></span></span></span></span></span></span></span></a> <a id="unionR_Locked" class="idref" href="#unionR_Locked"><span class="id" title="axiom, definition, module"><span id="unionR_Locked.body" class="id"><span id="unionR_Locked.unlock" class="id"><span id="unionR" class="id"><span id="unionR.body" class="id"><span id="unionR.unlock" class="id"><span id="unionR_unlock_subterm" class="id">:</span></span></span></span></span></span></span></a> <a id="unionR_Locked" class="idref" href="#unionR_Locked"><span class="id" title="axiom, definition, module"><span id="unionR_Locked.body" class="id"><span id="unionR_Locked.unlock" class="id"><span id="unionR" class="id"><span id="unionR.body" class="id"><span id="unionR.unlock" class="id"><span id="unionR_unlock_subterm" class="id">globname</span></span></span></span></span></span></span></a><a id="unionR_Locked" class="idref" href="#unionR_Locked"><span class="id" title="axiom, definition, module"><span id="unionR_Locked.body" class="id"><span id="unionR_Locked.unlock" class="id"><span id="unionR" class="id"><span id="unionR.body" class="id"><span id="unionR.unlock" class="id"><span id="unionR_unlock_subterm" class="id">)</span></span></span></span></span></span></span></a> <a id="unionR_Locked" class="idref" href="#unionR_Locked"><span class="id" title="axiom, definition, module"><span id="unionR_Locked.body" class="id"><span id="unionR_Locked.unlock" class="id"><span id="unionR" class="id"><span id="unionR.body" class="id"><span id="unionR.unlock" class="id"><span id="unionR_unlock_subterm" class="id">(</span></span></span></span></span></span></span></a><a id="q:16" class="idref" href="#q:16"><span class="id" title="axiom, binder, definition, module"><span id="q:23" class="id"><span id="unionR_Locked" class="id"><span id="unionR_Locked.body" class="id"><span id="unionR_Locked.unlock" class="id"><span id="unionR" class="id"><span id="unionR.body" class="id"><span id="unionR.unlock" class="id"><span id="unionR_unlock_subterm" class="id">q</span></span></span></span></span></span></span></span></span></a> <a id="unionR_Locked" class="idref" href="#unionR_Locked"><span class="id" title="axiom, definition, module"><span id="unionR_Locked.body" class="id"><span id="unionR_Locked.unlock" class="id"><span id="unionR" class="id"><span id="unionR.body" class="id"><span id="unionR.unlock" class="id"><span id="unionR_unlock_subterm" class="id">:</span></span></span></span></span></span></span></a> <a id="unionR_Locked" class="idref" href="#unionR_Locked"><span class="id" title="axiom, definition, module"><span id="unionR_Locked.body" class="id"><span id="unionR_Locked.unlock" class="id"><span id="unionR" class="id"><span id="unionR.body" class="id"><span id="unionR.unlock" class="id"><span id="unionR_unlock_subterm" class="id">cQp.t</span></span></span></span></span></span></span></a><a id="unionR_Locked" class="idref" href="#unionR_Locked"><span class="id" title="axiom, definition, module"><span id="unionR_Locked.body" class="id"><span id="unionR_Locked.unlock" class="id"><span id="unionR" class="id"><span id="unionR.body" class="id"><span id="unionR.unlock" class="id"><span id="unionR_unlock_subterm" class="id">)</span></span></span></span></span></span></span></a> <a id="unionR_Locked" class="idref" href="#unionR_Locked"><span class="id" title="axiom, definition, module"><span id="unionR_Locked.body" class="id"><span id="unionR_Locked.unlock" class="id"><span id="unionR" class="id"><span id="unionR.body" class="id"><span id="unionR.unlock" class="id"><span id="unionR_unlock_subterm" class="id">(</span></span></span></span></span></span></span></a><a id="i:17" class="idref" href="#i:17"><span class="id" title="axiom, binder, definition, module"><span id="i:24" class="id"><span id="unionR_Locked" class="id"><span id="unionR_Locked.body" class="id"><span id="unionR_Locked.unlock" class="id"><span id="unionR" class="id"><span id="unionR.body" class="id"><span id="unionR.unlock" class="id"><span id="unionR_unlock_subterm" class="id">i</span></span></span></span></span></span></span></span></span></a> <a id="unionR_Locked" class="idref" href="#unionR_Locked"><span class="id" title="axiom, definition, module"><span id="unionR_Locked.body" class="id"><span id="unionR_Locked.unlock" class="id"><span id="unionR" class="id"><span id="unionR.body" class="id"><span id="unionR.unlock" class="id"><span id="unionR_unlock_subterm" class="id">:</span></span></span></span></span></span></span></a> <a id="unionR_Locked" class="idref" href="#unionR_Locked"><span class="id" title="axiom, definition, module"><span id="unionR_Locked.body" class="id"><span id="unionR_Locked.unlock" class="id"><span id="unionR" class="id"><span id="unionR.body" class="id"><span id="unionR.unlock" class="id"><span id="unionR_unlock_subterm" class="id">option</span></span></span></span></span></span></span></a> <a id="unionR_Locked" class="idref" href="#unionR_Locked"><span class="id" title="axiom, definition, module"><span id="unionR_Locked.body" class="id"><span id="unionR_Locked.unlock" class="id"><span id="unionR" class="id"><span id="unionR.body" class="id"><span id="unionR.unlock" class="id"><span id="unionR_unlock_subterm" class="id">nat</span></span></span></span></span></span></span></a><a id="unionR_Locked" class="idref" href="#unionR_Locked"><span class="id" title="axiom, definition, module"><span id="unionR_Locked.body" class="id"><span id="unionR_Locked.unlock" class="id"><span id="unionR" class="id"><span id="unionR.body" class="id"><span id="unionR.unlock" class="id"><span id="unionR_unlock_subterm" class="id">)</span></span></span></span></span></span></span></a> <a id="unionR_Locked" class="idref" href="#unionR_Locked"><span class="id" title="axiom, definition, module"><span id="unionR_Locked.body" class="id"><span id="unionR_Locked.unlock" class="id"><span id="unionR" class="id"><span id="unionR.body" class="id"><span id="unionR.unlock" class="id"><span id="unionR_unlock_subterm" class="id">:</span></span></span></span></span></span></span></a> <a id="unionR_Locked" class="idref" href="#unionR_Locked"><span class="id" title="axiom, definition, module"><span id="unionR_Locked.body" class="id"><span id="unionR_Locked.unlock" class="id"><span id="unionR" class="id"><span id="unionR.body" class="id"><span id="unionR.unlock" class="id"><span id="unionR_unlock_subterm" class="id">Rep</span></span></span></span></span></span></span></a> <a id="unionR_Locked" class="idref" href="#unionR_Locked"><span class="id" title="axiom, definition, module"><span id="unionR_Locked.body" class="id"><span id="unionR_Locked.unlock" class="id"><span id="unionR" class="id"><span id="unionR.body" class="id"><span id="unionR.unlock" class="id"><span id="unionR_unlock_subterm" class="id">:=</span></span></span></span></span></span></span></a><br/>
&nbsp;&nbsp;<a id="unionR_Locked" class="idref" href="#unionR_Locked"><span class="id" title="axiom, definition, module"><span id="unionR_Locked.body" class="id"><span id="unionR_Locked.unlock" class="id"><span id="unionR" class="id"><span id="unionR.body" class="id"><span id="unionR.unlock" class="id"><span id="unionR_unlock_subterm" class="id">as_Rep</span></span></span></span></span></span></span></a> <a id="unionR_Locked" class="idref" href="#unionR_Locked"><span class="id" title="axiom, definition, module"><span id="unionR_Locked.body" class="id"><span id="unionR_Locked.unlock" class="id"><span id="unionR" class="id"><span id="unionR.body" class="id"><span id="unionR.unlock" class="id"><span id="unionR_unlock_subterm" class="id">(</span></span></span></span></span></span></span></a><a id="unionR_Locked" class="idref" href="#unionR_Locked"><span class="id" title="axiom, definition, module"><span id="unionR_Locked.body" class="id"><span id="unionR_Locked.unlock" class="id"><span id="unionR" class="id"><span id="unionR.body" class="id"><span id="unionR.unlock" class="id"><span id="unionR_unlock_subterm" class="id">fun</span></span></span></span></span></span></span></a> <a id="p:18" class="idref" href="#p:18"><span class="id" title="axiom, binder, definition, module"><span id="unionR_Locked" class="id"><span id="unionR_Locked.body" class="id"><span id="unionR_Locked.unlock" class="id"><span id="unionR" class="id"><span id="unionR.body" class="id"><span id="unionR.unlock" class="id"><span id="unionR_unlock_subterm" class="id">p</span></span></span></span></span></span></span></span></a> <a id="unionR_Locked" class="idref" href="#unionR_Locked"><span class="id" title="axiom, definition, module"><span id="unionR_Locked.body" class="id"><span id="unionR_Locked.unlock" class="id"><span id="unionR" class="id"><span id="unionR.body" class="id"><span id="unionR.unlock" class="id"><span id="unionR_unlock_subterm" class="id">=&gt;</span></span></span></span></span></span></span></a> <a id="unionR_Locked" class="idref" href="#unionR_Locked"><span class="id" title="axiom, definition, module"><span id="unionR_Locked.body" class="id"><span id="unionR_Locked.unlock" class="id"><span id="unionR" class="id"><span id="unionR.body" class="id"><span id="unionR.unlock" class="id"><span id="unionR_unlock_subterm" class="id">union_padding</span></span></span></span></span></span></span></a> <a id="unionR_Locked" class="idref" href="#unionR_Locked"><span class="id" title="axiom, definition, module"><span id="unionR_Locked.body" class="id"><span id="unionR_Locked.unlock" class="id"><span id="unionR" class="id"><span id="unionR.body" class="id"><span id="unionR.unlock" class="id"><span id="unionR_unlock_subterm" class="id">p</span></span></span></span></span></span></span></a> <a id="unionR_Locked" class="idref" href="#unionR_Locked"><span class="id" title="axiom, definition, module"><span id="unionR_Locked.body" class="id"><span id="unionR_Locked.unlock" class="id"><span id="unionR" class="id"><span id="unionR.body" class="id"><span id="unionR.unlock" class="id"><span id="unionR_unlock_subterm" class="id">cls</span></span></span></span></span></span></span></a> <a id="unionR_Locked" class="idref" href="#unionR_Locked"><span class="id" title="axiom, definition, module"><span id="unionR_Locked.body" class="id"><span id="unionR_Locked.unlock" class="id"><span id="unionR" class="id"><span id="unionR.body" class="id"><span id="unionR.unlock" class="id"><span id="unionR_unlock_subterm" class="id">q</span></span></span></span></span></span></span></a> <a id="unionR_Locked" class="idref" href="#unionR_Locked"><span class="id" title="axiom, definition, module"><span id="unionR_Locked.body" class="id"><span id="unionR_Locked.unlock" class="id"><span id="unionR" class="id"><span id="unionR.body" class="id"><span id="unionR.unlock" class="id"><span id="unionR_unlock_subterm" class="id">i</span></span></span></span></span></span></span></a><a id="unionR_Locked" class="idref" href="#unionR_Locked"><span class="id" title="axiom, definition, module"><span id="unionR_Locked.body" class="id"><span id="unionR_Locked.unlock" class="id"><span id="unionR" class="id"><span id="unionR.body" class="id"><span id="unionR.unlock" class="id"><span id="unionR_unlock_subterm" class="id">)</span></span></span></span></span></span></span></a>.<br/>
#[<span class="id" title="var">global</span>] <span class="id" title="var">Arguments</span> <a class="idref" href="bedrock.lang.cpp.logic.heap_pred.aggregate.html#body"><span class="id" title="axiom">unionR</span></a> {<span class="id" title="var">_</span> <span class="id" title="var">Σ</span> σ} <span class="id" title="var">cls</span> <span class="id" title="var">q</span> <span class="id" title="var">i</span> : <span class="id" title="tactic">assert</span>.<br/>

<br/>
<span class="id" title="keyword">Section</span> <a id="aggregate" class="idref" href="#aggregate"><span class="id" title="section">aggregate</span></a>.<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Context</span> `{<a id="e023703f3460855264e8fbe327a7ed6a" class="idref" href="#e023703f3460855264e8fbe327a7ed6a"><span class="id" title="binder">Σ</span></a> : <a class="idref" href="bedrock.lang.cpp.logic.mpred.html#LC.cpp_logic"><span class="id" title="class">cpp_logic</span></a>} {<a id="51578e5097ca1e0a116e50ad4dce93c4" class="idref" href="#51578e5097ca1e0a116e50ad4dce93c4"><span class="id" title="binder">σ</span></a> : <a class="idref" href="bedrock.lang.cpp.semantics.genv.html#genv"><span class="id" title="class">genv</span></a>}.<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Variable</span> <a id="aggregate.cls" class="idref" href="#aggregate.cls"><span class="id" title="variable">cls</span></a> : <a class="idref" href="bedrock.lang.cpp.syntax.names.html#globname"><span class="id" title="definition">globname</span></a>.<br/>

<br/>
&nbsp;&nbsp;#[<span class="id" title="var">global</span>] <span class="id" title="keyword">Instance</span> <a id="structR_fractional" class="idref" href="#structR_fractional"><span class="id" title="instance">structR_fractional</span></a> : <a class="idref" href="bedrock.lang.cpp.bi.cfractional.html#CFractional"><span class="id" title="class">CFractional</span></a> (<a class="idref" href="bedrock.lang.cpp.logic.heap_pred.aggregate.html#structR"><span class="id" title="abbreviation">structR</span></a> <a class="idref" href="bedrock.lang.cpp.logic.heap_pred.aggregate.html#aggregate.cls"><span class="id" title="variable">cls</span></a>).<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Proof</span>. <span class="id" title="tactic">rewrite</span> <a class="idref" href="bedrock.lang.cpp.logic.heap_pred.aggregate.html#unlock"><span class="id" title="axiom">structR.unlock</span></a>; <span class="id" title="tactic">eapply</span> <a class="idref" href="bedrock.lang.cpp.logic.rep.html#as_Rep_cfractional"><span class="id" title="instance">as_Rep_cfractional</span></a> =&gt; ?; <span class="id" title="tactic">eapply</span> <a class="idref" href="bedrock.lang.cpp.logic.pred.html#L.struct_padding_fractional"><span class="id" title="axiom">struct_padding_fractional</span></a>. <span class="id" title="keyword">Qed</span>.<br/>
&nbsp;&nbsp;#[<span class="id" title="var">global</span>] <span class="id" title="keyword">Instance</span> <a id="structR_cfractional_eta" class="idref" href="#structR_cfractional_eta"><span class="id" title="instance">structR_cfractional_eta</span></a> : <a class="idref" href="bedrock.lang.cpp.bi.cfractional.html#CFractional"><span class="id" title="class">CFractional</span></a> (<span class="id" title="keyword">fun</span> <a id="q:29" class="idref" href="#q:29"><span class="id" title="binder">q</span></a> =&gt; <a class="idref" href="bedrock.lang.cpp.logic.heap_pred.aggregate.html#structR"><span class="id" title="abbreviation">structR</span></a> <a class="idref" href="bedrock.lang.cpp.logic.heap_pred.aggregate.html#aggregate.cls"><span class="id" title="variable">cls</span></a> <a class="idref" href="bedrock.lang.cpp.logic.heap_pred.aggregate.html#q:29"><span class="id" title="variable">q</span></a>).<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Proof</span>. <span class="id" title="tactic">apply</span> <a class="idref" href="bedrock.lang.cpp.logic.heap_pred.aggregate.html#structR_fractional"><span class="id" title="instance">structR_fractional</span></a>. <span class="id" title="keyword">Qed</span>.<br/>

<br/>
&nbsp;&nbsp;#[<span class="id" title="var">global</span>] <span class="id" title="keyword">Instance</span> <a id="structR_timeless" class="idref" href="#structR_timeless"><span class="id" title="instance">structR_timeless</span></a> : <a class="idref" href="bedrock.lang.bi.derived_laws.html#nary.Timeless2"><span class="id" title="abbreviation">Timeless2</span></a> <a class="idref" href="bedrock.lang.cpp.logic.heap_pred.aggregate.html#structR"><span class="id" title="abbreviation">structR</span></a>.<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Proof</span>. <span class="id" title="tactic">rewrite</span> <a class="idref" href="bedrock.lang.cpp.logic.heap_pred.aggregate.html#unlock"><span class="id" title="axiom">structR.unlock</span></a>; <span class="id" title="tactic">apply</span> <span class="id" title="var">_</span>. <span class="id" title="keyword">Qed</span>.<br/>
&nbsp;&nbsp;#[<span class="id" title="var">global</span>] <span class="id" title="keyword">Instance</span> <a id="structR_frac_valid" class="idref" href="#structR_frac_valid"><span class="id" title="instance">structR_frac_valid</span></a> : <a class="idref" href="bedrock.lang.cpp.bi.cfractional.html#CFracValid0"><span class="id" title="class">CFracValid0</span></a> (<a class="idref" href="bedrock.lang.cpp.logic.heap_pred.aggregate.html#structR"><span class="id" title="abbreviation">structR</span></a> <a class="idref" href="bedrock.lang.cpp.logic.heap_pred.aggregate.html#aggregate.cls"><span class="id" title="variable">cls</span></a>).<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Proof</span>. <span class="id" title="tactic">rewrite</span> <a class="idref" href="bedrock.lang.cpp.logic.heap_pred.aggregate.html#unlock"><span class="id" title="axiom">structR.unlock</span></a>. <span class="id" title="tactic">constructor</span>. <span class="id" title="tactic">intros</span>; <span class="id" title="tactic">apply</span> <a class="idref" href="bedrock.lang.cpp.logic.rep.html#as_Rep_only_provable_observe"><span class="id" title="instance">as_Rep_only_provable_observe</span></a>. <span class="id" title="tactic">refine</span> <span class="id" title="var">_</span>. <span class="id" title="keyword">Qed</span>.<br/>
&nbsp;&nbsp;#[<span class="id" title="var">global</span>] <span class="id" title="keyword">Instance</span> <a id="structR_frac_valid_eta" class="idref" href="#structR_frac_valid_eta"><span class="id" title="instance">structR_frac_valid_eta</span></a> : <a class="idref" href="bedrock.lang.cpp.bi.cfractional.html#CFracValid0"><span class="id" title="class">CFracValid0</span></a> (<span class="id" title="keyword">fun</span> <a id="q:30" class="idref" href="#q:30"><span class="id" title="binder">q</span></a> =&gt; <a class="idref" href="bedrock.lang.cpp.logic.heap_pred.aggregate.html#structR"><span class="id" title="abbreviation">structR</span></a> <a class="idref" href="bedrock.lang.cpp.logic.heap_pred.aggregate.html#aggregate.cls"><span class="id" title="variable">cls</span></a> <a class="idref" href="bedrock.lang.cpp.logic.heap_pred.aggregate.html#q:30"><span class="id" title="variable">q</span></a>).<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Proof</span>. <span class="id" title="tactic">apply</span> <a class="idref" href="bedrock.lang.cpp.logic.heap_pred.aggregate.html#structR_frac_valid"><span class="id" title="instance">structR_frac_valid</span></a>. <span class="id" title="keyword">Qed</span>.<br/>

<br/>
&nbsp;&nbsp;#[<span class="id" title="var">global</span>] <span class="id" title="keyword">Instance</span> <a id="structR_as_fractional" class="idref" href="#structR_as_fractional"><span class="id" title="instance">structR_as_fractional</span></a> : <a class="idref" href="bedrock.lang.cpp.bi.cfractional.html#AsCFractional0"><span class="id" title="abbreviation">AsCFractional0</span></a> (<a class="idref" href="bedrock.lang.cpp.logic.heap_pred.aggregate.html#structR"><span class="id" title="abbreviation">structR</span></a> <a class="idref" href="bedrock.lang.cpp.logic.heap_pred.aggregate.html#aggregate.cls"><span class="id" title="variable">cls</span></a>).<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Proof</span>. <span class="id" title="var">solve_as_cfrac</span>. <span class="id" title="keyword">Qed</span>.<br/>

<br/>
&nbsp;&nbsp;#[<span class="id" title="var">global</span>] <span class="id" title="keyword">Instance</span> <a id="union_fractional" class="idref" href="#union_fractional"><span class="id" title="instance">union_fractional</span></a> : <a class="idref" href="bedrock.lang.cpp.bi.cfractional.html#CFractional1"><span class="id" title="abbreviation">CFractional1</span></a> (<a class="idref" href="bedrock.lang.cpp.logic.heap_pred.aggregate.html#unionR"><span class="id" title="abbreviation">unionR</span></a> <a class="idref" href="bedrock.lang.cpp.logic.heap_pred.aggregate.html#aggregate.cls"><span class="id" title="variable">cls</span></a>).<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Proof</span>. <span class="id" title="tactic">rewrite</span> <a class="idref" href="bedrock.lang.cpp.logic.heap_pred.aggregate.html#unlock"><span class="id" title="axiom">unionR.unlock</span></a>; <span class="id" title="tactic">intros</span>; <span class="id" title="tactic">eapply</span> <a class="idref" href="bedrock.lang.cpp.logic.rep.html#as_Rep_cfractional"><span class="id" title="instance">as_Rep_cfractional</span></a> =&gt; ?; <span class="id" title="tactic">eapply</span> <a class="idref" href="bedrock.lang.cpp.logic.pred.html#L.union_padding_fractional"><span class="id" title="axiom">union_padding_fractional</span></a>. <span class="id" title="keyword">Qed</span>.<br/>
&nbsp;&nbsp;#[<span class="id" title="var">global</span>] <span class="id" title="keyword">Instance</span> <a id="union_timeless" class="idref" href="#union_timeless"><span class="id" title="instance">union_timeless</span></a> : <a class="idref" href="bedrock.lang.bi.derived_laws.html#nary.Timeless3"><span class="id" title="abbreviation">Timeless3</span></a> <a class="idref" href="bedrock.lang.cpp.logic.heap_pred.aggregate.html#unionR"><span class="id" title="abbreviation">unionR</span></a>.<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Proof</span>. <span class="id" title="tactic">rewrite</span> <a class="idref" href="bedrock.lang.cpp.logic.heap_pred.aggregate.html#unlock"><span class="id" title="axiom">unionR.unlock</span></a>; <span class="id" title="tactic">apply</span> <span class="id" title="var">_</span>. <span class="id" title="keyword">Qed</span>.<br/>
&nbsp;&nbsp;#[<span class="id" title="var">global</span>] <span class="id" title="keyword">Instance</span> <a id="union_frac_valid" class="idref" href="#union_frac_valid"><span class="id" title="instance">union_frac_valid</span></a> : <a class="idref" href="bedrock.lang.cpp.bi.cfractional.html#CFracValid1"><span class="id" title="class">CFracValid1</span></a> (<a class="idref" href="bedrock.lang.cpp.logic.heap_pred.aggregate.html#unionR"><span class="id" title="abbreviation">unionR</span></a> <a class="idref" href="bedrock.lang.cpp.logic.heap_pred.aggregate.html#aggregate.cls"><span class="id" title="variable">cls</span></a>).<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Proof</span>. <span class="id" title="tactic">rewrite</span> <a class="idref" href="bedrock.lang.cpp.logic.heap_pred.aggregate.html#unlock"><span class="id" title="axiom">unionR.unlock</span></a>. <span class="id" title="tactic">constructor</span>. <span class="id" title="tactic">intros</span>; <span class="id" title="tactic">apply</span> <a class="idref" href="bedrock.lang.cpp.logic.rep.html#as_Rep_only_provable_observe"><span class="id" title="instance">as_Rep_only_provable_observe</span></a>. <span class="id" title="tactic">refine</span> <span class="id" title="var">_</span>. <span class="id" title="keyword">Qed</span>.<br/>

<br/>
&nbsp;&nbsp;#[<span class="id" title="var">global</span>] <span class="id" title="keyword">Instance</span> <a id="union_as_fractional" class="idref" href="#union_as_fractional"><span class="id" title="instance">union_as_fractional</span></a> : <a class="idref" href="bedrock.lang.cpp.bi.cfractional.html#AsCFractional1"><span class="id" title="abbreviation">AsCFractional1</span></a> (<a class="idref" href="bedrock.lang.cpp.logic.heap_pred.aggregate.html#unionR"><span class="id" title="abbreviation">unionR</span></a> <a class="idref" href="bedrock.lang.cpp.logic.heap_pred.aggregate.html#aggregate.cls"><span class="id" title="variable">cls</span></a>).<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Proof</span>. <span class="id" title="var">solve_as_cfrac</span>. <span class="id" title="keyword">Qed</span>.<br/>

<br/>
&nbsp;&nbsp;#[<span class="id" title="var">global</span>] <span class="id" title="keyword">Instance</span> <a id="structR_type_ptr_observe" class="idref" href="#structR_type_ptr_observe"><span class="id" title="instance">structR_type_ptr_observe</span></a> : <span class="id" title="notation">forall</span> <a id="q:31" class="idref" href="#q:31"><span class="id" title="binder">q</span></a> <a id="cls:32" class="idref" href="#cls:32"><span class="id" title="binder">cls</span></a><span class="id" title="notation">,</span> <a class="idref" href="bedrock.lang.bi.observe.html#Observe"><span class="id" title="class">Observe</span></a> (<a class="idref" href="bedrock.lang.cpp.logic.heap_pred.valid.html#type_ptrR"><span class="id" title="definition">type_ptrR</span></a> (<a class="idref" href="bedrock.lang.cpp.syntax.types.html#Tnamed"><span class="id" title="constructor">Tnamed</span></a> <a class="idref" href="bedrock.lang.cpp.logic.heap_pred.aggregate.html#cls:32"><span class="id" title="variable">cls</span></a>)) (<a class="idref" href="bedrock.lang.cpp.logic.heap_pred.aggregate.html#structR"><span class="id" title="abbreviation">structR</span></a> <a class="idref" href="bedrock.lang.cpp.logic.heap_pred.aggregate.html#cls:32"><span class="id" title="variable">cls</span></a> <a class="idref" href="bedrock.lang.cpp.logic.heap_pred.aggregate.html#q:31"><span class="id" title="variable">q</span></a>).<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">intros</span>; <span class="id" title="tactic">eapply</span> <a class="idref" href="bedrock.lang.cpp.logic.rep.html#observe_at"><span class="id" title="lemma">observe_at</span></a>; <span class="id" title="tactic">intros</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> <a class="idref" href="bedrock.lang.cpp.logic.heap_pred.valid.html#_at_type_ptrR"><span class="id" title="lemma">_at_type_ptrR</span></a> <a class="idref" href="bedrock.lang.cpp.logic.heap_pred.aggregate.html#unlock"><span class="id" title="axiom">structR.unlock</span></a> <a class="idref" href="bedrock.lang.cpp.logic.rep.html#_at_as_Rep"><span class="id" title="lemma">_at_as_Rep</span></a>. <span class="id" title="tactic">refine</span> <span class="id" title="var">_</span>.<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Qed</span>.<br/>
&nbsp;&nbsp;#[<span class="id" title="var">global</span>] <span class="id" title="keyword">Instance</span> <a id="structR_strict_valid_observe" class="idref" href="#structR_strict_valid_observe"><span class="id" title="instance">structR_strict_valid_observe</span></a> <a id="q:33" class="idref" href="#q:33"><span class="id" title="binder">q</span></a> : <a class="idref" href="bedrock.lang.bi.observe.html#Observe"><span class="id" title="class">Observe</span></a> <a class="idref" href="bedrock.lang.cpp.logic.heap_pred.valid.html#svalidR"><span class="id" title="definition">svalidR</span></a> (<a class="idref" href="bedrock.lang.cpp.logic.heap_pred.aggregate.html#structR"><span class="id" title="abbreviation">structR</span></a> <a class="idref" href="bedrock.lang.cpp.logic.heap_pred.aggregate.html#aggregate.cls"><span class="id" title="variable">cls</span></a> <a class="idref" href="bedrock.lang.cpp.logic.heap_pred.aggregate.html#q:33"><span class="id" title="variable">q</span></a>).<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Proof</span>. <span class="id" title="tactic">rewrite</span> -<a class="idref" href="bedrock.lang.cpp.logic.heap_pred.valid.html#type_ptrR_svalidR"><span class="id" title="lemma">type_ptrR_svalidR</span></a>; <span class="id" title="tactic">apply</span> <span class="id" title="var">_</span>. <span class="id" title="keyword">Qed</span>.<br/>
&nbsp;&nbsp;#[<span class="id" title="var">global</span>] <span class="id" title="keyword">Instance</span> <a id="structR_valid_observe" class="idref" href="#structR_valid_observe"><span class="id" title="instance">structR_valid_observe</span></a> <a id="q:34" class="idref" href="#q:34"><span class="id" title="binder">q</span></a> : <a class="idref" href="bedrock.lang.bi.observe.html#Observe"><span class="id" title="class">Observe</span></a> <a class="idref" href="bedrock.lang.cpp.logic.heap_pred.valid.html#validR"><span class="id" title="definition">validR</span></a> (<a class="idref" href="bedrock.lang.cpp.logic.heap_pred.aggregate.html#structR"><span class="id" title="abbreviation">structR</span></a> <a class="idref" href="bedrock.lang.cpp.logic.heap_pred.aggregate.html#aggregate.cls"><span class="id" title="variable">cls</span></a> <a class="idref" href="bedrock.lang.cpp.logic.heap_pred.aggregate.html#q:34"><span class="id" title="variable">q</span></a>).<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Proof</span>. <span class="id" title="tactic">rewrite</span> -<a class="idref" href="bedrock.lang.cpp.logic.heap_pred.valid.html#svalidR_validR"><span class="id" title="lemma">svalidR_validR</span></a>; <span class="id" title="tactic">apply</span> <span class="id" title="var">_</span>. <span class="id" title="keyword">Qed</span>.<br/>

<br/>
&nbsp;&nbsp;#[<span class="id" title="var">global</span>] <span class="id" title="keyword">Instance</span> <a id="structR_nonnull" class="idref" href="#structR_nonnull"><span class="id" title="instance">structR_nonnull</span></a> <a id="q:35" class="idref" href="#q:35"><span class="id" title="binder">q</span></a> : <a class="idref" href="bedrock.lang.bi.observe.html#Observe"><span class="id" title="class">Observe</span></a> <a class="idref" href="bedrock.lang.cpp.logic.heap_pred.null.html#nonnullR"><span class="id" title="abbreviation">nonnullR</span></a> (<a class="idref" href="bedrock.lang.cpp.logic.heap_pred.aggregate.html#structR"><span class="id" title="abbreviation">structR</span></a> <a class="idref" href="bedrock.lang.cpp.logic.heap_pred.aggregate.html#aggregate.cls"><span class="id" title="variable">cls</span></a> <a class="idref" href="bedrock.lang.cpp.logic.heap_pred.aggregate.html#q:35"><span class="id" title="variable">q</span></a>).<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">iIntros</span> "H".<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">iDestruct</span> <span class="id" title="notation">(</span><a class="idref" href="bedrock.lang.bi.observe.html#observe"><span class="id" title="definition">observe</span></a> (<a class="idref" href="bedrock.lang.cpp.logic.heap_pred.valid.html#type_ptrR"><span class="id" title="definition">type_ptrR</span></a> <span class="id" title="var">_</span>) <span class="id" title="notation">with</span> "H"<span class="id" title="notation">)</span> <span class="id" title="keyword">as</span> "#T".<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">iApply</span> <span class="id" title="notation">(</span><a class="idref" href="bedrock.lang.bi.observe.html#observe"><span class="id" title="definition">observe</span></a> <span class="id" title="notation">with</span> "T"<span class="id" title="notation">)</span>.<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Qed</span>.<br/>

<br/>
&nbsp;&nbsp;#[<span class="id" title="var">global</span>] <span class="id" title="keyword">Instance</span> <a id="unionR_type_ptr_observe" class="idref" href="#unionR_type_ptr_observe"><span class="id" title="instance">unionR_type_ptr_observe</span></a> : <span class="id" title="notation">forall</span> <a id="q:36" class="idref" href="#q:36"><span class="id" title="binder">q</span></a> <a id="i:37" class="idref" href="#i:37"><span class="id" title="binder">i</span></a><span class="id" title="notation">,</span> <a class="idref" href="bedrock.lang.bi.observe.html#Observe"><span class="id" title="class">Observe</span></a> (<a class="idref" href="bedrock.lang.cpp.logic.heap_pred.valid.html#type_ptrR"><span class="id" title="definition">type_ptrR</span></a> (<a class="idref" href="bedrock.lang.cpp.syntax.types.html#Tnamed"><span class="id" title="constructor">Tnamed</span></a> <a class="idref" href="bedrock.lang.cpp.logic.heap_pred.aggregate.html#aggregate.cls"><span class="id" title="variable">cls</span></a>)) (<a class="idref" href="bedrock.lang.cpp.logic.heap_pred.aggregate.html#unionR"><span class="id" title="abbreviation">unionR</span></a> <a class="idref" href="bedrock.lang.cpp.logic.heap_pred.aggregate.html#aggregate.cls"><span class="id" title="variable">cls</span></a> <a class="idref" href="bedrock.lang.cpp.logic.heap_pred.aggregate.html#q:36"><span class="id" title="variable">q</span></a> <a class="idref" href="bedrock.lang.cpp.logic.heap_pred.aggregate.html#i:37"><span class="id" title="variable">i</span></a>).<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">intros</span>; <span class="id" title="tactic">eapply</span> <a class="idref" href="bedrock.lang.cpp.logic.rep.html#observe_at"><span class="id" title="lemma">observe_at</span></a>; <span class="id" title="tactic">intros</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> <a class="idref" href="bedrock.lang.cpp.logic.heap_pred.valid.html#_at_type_ptrR"><span class="id" title="lemma">_at_type_ptrR</span></a> <a class="idref" href="bedrock.lang.cpp.logic.heap_pred.aggregate.html#unlock"><span class="id" title="axiom">unionR.unlock</span></a> <a class="idref" href="bedrock.lang.cpp.logic.rep.html#_at_as_Rep"><span class="id" title="lemma">_at_as_Rep</span></a>. <span class="id" title="tactic">refine</span> <span class="id" title="var">_</span>.<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Qed</span>.<br/>
&nbsp;&nbsp;#[<span class="id" title="var">global</span>] <span class="id" title="keyword">Instance</span> <a id="unionR_strict_valid_observe" class="idref" href="#unionR_strict_valid_observe"><span class="id" title="instance">unionR_strict_valid_observe</span></a> <a id="q:38" class="idref" href="#q:38"><span class="id" title="binder">q</span></a> <a id="i:39" class="idref" href="#i:39"><span class="id" title="binder">i</span></a> : <a class="idref" href="bedrock.lang.bi.observe.html#Observe"><span class="id" title="class">Observe</span></a> <a class="idref" href="bedrock.lang.cpp.logic.heap_pred.valid.html#svalidR"><span class="id" title="definition">svalidR</span></a> (<a class="idref" href="bedrock.lang.cpp.logic.heap_pred.aggregate.html#unionR"><span class="id" title="abbreviation">unionR</span></a> <a class="idref" href="bedrock.lang.cpp.logic.heap_pred.aggregate.html#aggregate.cls"><span class="id" title="variable">cls</span></a> <a class="idref" href="bedrock.lang.cpp.logic.heap_pred.aggregate.html#q:38"><span class="id" title="variable">q</span></a> <a class="idref" href="bedrock.lang.cpp.logic.heap_pred.aggregate.html#i:39"><span class="id" title="variable">i</span></a>).<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Proof</span>. <span class="id" title="tactic">rewrite</span> -<a class="idref" href="bedrock.lang.cpp.logic.heap_pred.valid.html#type_ptrR_svalidR"><span class="id" title="lemma">type_ptrR_svalidR</span></a>; <span class="id" title="tactic">apply</span> <span class="id" title="var">_</span>. <span class="id" title="keyword">Qed</span>.<br/>
&nbsp;&nbsp;#[<span class="id" title="var">global</span>] <span class="id" title="keyword">Instance</span> <a id="unionR_valid_observe" class="idref" href="#unionR_valid_observe"><span class="id" title="instance">unionR_valid_observe</span></a> <a id="q:40" class="idref" href="#q:40"><span class="id" title="binder">q</span></a> <a id="i:41" class="idref" href="#i:41"><span class="id" title="binder">i</span></a> : <a class="idref" href="bedrock.lang.bi.observe.html#Observe"><span class="id" title="class">Observe</span></a> <a class="idref" href="bedrock.lang.cpp.logic.heap_pred.valid.html#validR"><span class="id" title="definition">validR</span></a> (<a class="idref" href="bedrock.lang.cpp.logic.heap_pred.aggregate.html#unionR"><span class="id" title="abbreviation">unionR</span></a> <a class="idref" href="bedrock.lang.cpp.logic.heap_pred.aggregate.html#aggregate.cls"><span class="id" title="variable">cls</span></a> <a class="idref" href="bedrock.lang.cpp.logic.heap_pred.aggregate.html#q:40"><span class="id" title="variable">q</span></a> <a class="idref" href="bedrock.lang.cpp.logic.heap_pred.aggregate.html#i:41"><span class="id" title="variable">i</span></a>).<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Proof</span>. <span class="id" title="tactic">rewrite</span> -<a class="idref" href="bedrock.lang.cpp.logic.heap_pred.valid.html#svalidR_validR"><span class="id" title="lemma">svalidR_validR</span></a>; <span class="id" title="tactic">apply</span> <span class="id" title="var">_</span>. <span class="id" title="keyword">Qed</span>.<br/>

<br/>
&nbsp;&nbsp;#[<span class="id" title="var">global</span>] <span class="id" title="keyword">Instance</span> <a id="unionR_nonnull" class="idref" href="#unionR_nonnull"><span class="id" title="instance">unionR_nonnull</span></a> <a id="q:42" class="idref" href="#q:42"><span class="id" title="binder">q</span></a> <a id="i:43" class="idref" href="#i:43"><span class="id" title="binder">i</span></a> : <a class="idref" href="bedrock.lang.bi.observe.html#Observe"><span class="id" title="class">Observe</span></a> <a class="idref" href="bedrock.lang.cpp.logic.heap_pred.null.html#nonnullR"><span class="id" title="abbreviation">nonnullR</span></a> (<a class="idref" href="bedrock.lang.cpp.logic.heap_pred.aggregate.html#unionR"><span class="id" title="abbreviation">unionR</span></a> <a class="idref" href="bedrock.lang.cpp.logic.heap_pred.aggregate.html#aggregate.cls"><span class="id" title="variable">cls</span></a> <a class="idref" href="bedrock.lang.cpp.logic.heap_pred.aggregate.html#q:42"><span class="id" title="variable">q</span></a> <a class="idref" href="bedrock.lang.cpp.logic.heap_pred.aggregate.html#i:43"><span class="id" title="variable">i</span></a>).<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">iIntros</span> "H".<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">iDestruct</span> <span class="id" title="notation">(</span><a class="idref" href="bedrock.lang.bi.observe.html#observe"><span class="id" title="definition">observe</span></a> (<a class="idref" href="bedrock.lang.cpp.logic.heap_pred.valid.html#type_ptrR"><span class="id" title="definition">type_ptrR</span></a> <span class="id" title="var">_</span>) <span class="id" title="notation">with</span> "H"<span class="id" title="notation">)</span> <span class="id" title="keyword">as</span> "#T".<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">iApply</span> <span class="id" title="notation">(</span><a class="idref" href="bedrock.lang.bi.observe.html#observe"><span class="id" title="definition">observe</span></a> <span class="id" title="notation">with</span> "T"<span class="id" title="notation">)</span>.<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Qed</span>.<br/>

<br/>
&nbsp;&nbsp;#[<span class="id" title="var">global</span>] <span class="id" title="keyword">Instance</span> <a id="unionR_agree" class="idref" href="#unionR_agree"><span class="id" title="instance">unionR_agree</span></a> <a id="q:44" class="idref" href="#q:44"><span class="id" title="binder">q</span></a> <a id="q':45" class="idref" href="#q':45"><span class="id" title="binder">q'</span></a> <a id="i:46" class="idref" href="#i:46"><span class="id" title="binder">i</span></a> <a id="i':47" class="idref" href="#i':47"><span class="id" title="binder">i'</span></a> :<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="bedrock.lang.bi.observe.html#Observe2"><span class="id" title="class">Observe2</span></a> <a class="idref" href="bedrock.lang.bi.only_provable.html#d95ff2fe2904cc1067c71e0d017740c6"><span class="id" title="notation">[|</span></a> <a class="idref" href="bedrock.lang.cpp.logic.heap_pred.aggregate.html#i:46"><span class="id" title="variable">i</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.18.0/stdlib//Coq.Init.Logic.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="bedrock.lang.cpp.logic.heap_pred.aggregate.html#i':47"><span class="id" title="variable">i'</span></a> <a class="idref" href="bedrock.lang.bi.only_provable.html#d95ff2fe2904cc1067c71e0d017740c6"><span class="id" title="notation">|]</span></a> (<a class="idref" href="bedrock.lang.cpp.logic.heap_pred.aggregate.html#unionR"><span class="id" title="abbreviation">unionR</span></a> <a class="idref" href="bedrock.lang.cpp.logic.heap_pred.aggregate.html#aggregate.cls"><span class="id" title="variable">cls</span></a> <a class="idref" href="bedrock.lang.cpp.logic.heap_pred.aggregate.html#q:44"><span class="id" title="variable">q</span></a> <a class="idref" href="bedrock.lang.cpp.logic.heap_pred.aggregate.html#i:46"><span class="id" title="variable">i</span></a>) (<a class="idref" href="bedrock.lang.cpp.logic.heap_pred.aggregate.html#unionR"><span class="id" title="abbreviation">unionR</span></a> <a class="idref" href="bedrock.lang.cpp.logic.heap_pred.aggregate.html#aggregate.cls"><span class="id" title="variable">cls</span></a> <a class="idref" href="bedrock.lang.cpp.logic.heap_pred.aggregate.html#q':45"><span class="id" title="variable">q'</span></a> <a class="idref" href="bedrock.lang.cpp.logic.heap_pred.aggregate.html#i':47"><span class="id" title="variable">i'</span></a>).<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Proof</span>. <span class="id" title="tactic">rewrite</span> <a class="idref" href="bedrock.lang.cpp.logic.heap_pred.aggregate.html#unlock"><span class="id" title="axiom">unionR.unlock</span></a>. <span class="id" title="tactic">eapply</span> <a class="idref" href="bedrock.lang.cpp.logic.rep.html#observe_2_at"><span class="id" title="lemma">observe_2_at</span></a>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">intros</span>; <span class="id" title="tactic">rewrite</span> <a class="idref" href="bedrock.lang.cpp.logic.rep.html#_at_only_provable"><span class="id" title="lemma">_at_only_provable</span></a> !<a class="idref" href="bedrock.lang.cpp.logic.rep.html#_at_as_Rep"><span class="id" title="lemma">_at_as_Rep</span></a>. <span class="id" title="tactic">refine</span> <span class="id" title="var">_</span>.<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Qed</span>.<br/>

<br/>
<span class="id" title="keyword">End</span> <a class="idref" href="bedrock.lang.cpp.logic.heap_pred.aggregate.html#aggregate"><span class="id" title="section">aggregate</span></a>.<br/>
</div>
<!--
-- Copyright (c) 2020 BedRock Systems, Inc.
-- This software is distributed under the terms of the BedRock Open-Source License.
-- See the LICENSE-BedRock file in the repository root for details.
-->

<!--
-- SPDX-LIcense-Identifier:BSD-2-Clause
-->
</div>
<div id="footer">
  Generated by <a href="http://coq.inria.fr/">coqdoc</a> and improved with <a href="https://github.com/tebbi/coqdocjs">CoqdocJS</a>
</div>
</div>
</body>

</html>
