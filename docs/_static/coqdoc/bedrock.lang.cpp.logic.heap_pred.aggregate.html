<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<!--
-- Copyright (c) 2020 BedRock Systems, Inc.
-- This software is distributed under the terms of the BedRock Open-Source License.
-- See the LICENSE-BedRock file in the repository root for details.
-->

<!--
-- SPDX-LIcense-Identifier:BSD-2-Clause
-->
<html xmlns="http://www.w3.org/1999/xhtml">

<head>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<link href="../css/coqdocjs/coqdoc.css" rel="stylesheet" type="text/css" />
<link href="../css/coqdocjs/coqdocjs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../js/coqdocjs/config.js"></script>
<script type="text/javascript" src="../js/coqdocjs/coqdocjs.js"></script>
</head>

<body onload="document.getElementById('content').focus()">
  <div id="header">
    <span class="left">
      <span class="modulename"> <script> document.write(document.title) </script> </span>
    </span>

    <span class="button" id="toggle-proofs"></span>

    <!-- NOTE: These are displayed right to left on the page -->
    <span class="right">
      <a href="./indexpage.html"> Index </a>
      <a href="./toc.html"> `theories/` </a>
      <a href="../../index.html"> Toplevel </a>
    </span>
</div>
    <div id="content" tabindex="-1" onblur="document.getElementById('content').focus()">
    <div id="main">
<h1 class="libtitle">bedrock.lang.cpp.logic.heap_pred.aggregate</h1>

<div class="code">
<span class="comment">(*<br/>
&nbsp;*&nbsp;Copyright&nbsp;(c)&nbsp;2023&nbsp;BedRock&nbsp;Systems,&nbsp;Inc.<br/>
&nbsp;*&nbsp;This&nbsp;software&nbsp;is&nbsp;distributed&nbsp;under&nbsp;the&nbsp;terms&nbsp;of&nbsp;the&nbsp;BedRock&nbsp;Open-Source&nbsp;License.<br/>
&nbsp;*&nbsp;See&nbsp;the&nbsp;LICENSE-BedRock&nbsp;file&nbsp;in&nbsp;the&nbsp;repository&nbsp;root&nbsp;for&nbsp;details.<br/>
&nbsp;*)</span><br/>

<br/>
<span class="id" title="keyword">Require</span> <span class="id" title="keyword">Import</span> <a class="idref" href="bedrock.lang.cpp.logic.heap_pred.prelude.html#"><span class="id" title="library">bedrock.lang.cpp.logic.heap_pred.prelude</span></a>.<br/>
<span class="id" title="keyword">Require</span> <span class="id" title="keyword">Import</span> <a class="idref" href="bedrock.lang.cpp.logic.heap_pred.valid.html#"><span class="id" title="library">bedrock.lang.cpp.logic.heap_pred.valid</span></a>.<br/>
<span class="id" title="keyword">Require</span> <span class="id" title="keyword">Import</span> <a class="idref" href="bedrock.lang.cpp.logic.heap_pred.null.html#"><span class="id" title="library">bedrock.lang.cpp.logic.heap_pred.null</span></a>.<br/>

<br/>
#[<span class="id" title="var">local</span>] <span class="id" title="keyword">Set</span> <span class="id" title="keyword">Printing</span> <span class="id" title="var">Coercions</span>.<br/>
<span class="id" title="keyword">Implicit</span> <span class="id" title="keyword">Types</span> (σ : <a class="idref" href="bedrock.lang.cpp.semantics.genv.html#genv"><span class="id" title="class">genv</span></a>) (<span class="id" title="var">p</span> : <a class="idref" href="bedrock.lang.cpp.semantics.values.html#PTRS_INTF_AXIOM.ptr"><span class="id" title="axiom">ptr</span></a>) (<span class="id" title="var">o</span> : <a class="idref" href="bedrock.lang.cpp.semantics.values.html#PTRS_INTF_AXIOM.offset"><span class="id" title="axiom">offset</span></a>).<br/>

<br/>
<a id="structR_Locked" class="idref" href="#structR_Locked"><span class="id" title="axiom, definition, module"><span id="structR_Locked.body" class="id"><span id="structR_Locked.unlock" class="id"><span id="structR" class="id"><span id="structR.body" class="id"><span id="structR.unlock" class="id"><span id="structR_unlock_subterm" class="id">mlock</span></span></span></span></span></span></span></a><br/>
<a id="structR_Locked" class="idref" href="#structR_Locked"><span class="id" title="axiom, definition, module"><span id="structR_Locked.body" class="id"><span id="structR_Locked.unlock" class="id"><span id="structR" class="id"><span id="structR.body" class="id"><span id="structR.unlock" class="id"><span id="structR_unlock_subterm" class="id">Definition</span></span></span></span></span></span></span></a> <a id="structR_Locked" class="idref" href="#structR_Locked"><span class="id" title="axiom, definition, module"><span id="structR_Locked.body" class="id"><span id="structR_Locked.unlock" class="id"><span id="structR" class="id"><span id="structR.body" class="id"><span id="structR.unlock" class="id"><span id="structR_unlock_subterm" class="id">structR</span></span></span></span></span></span></span></a> <a id="structR_Locked" class="idref" href="#structR_Locked"><span class="id" title="axiom, definition, module"><span id="structR_Locked.body" class="id"><span id="structR_Locked.unlock" class="id"><span id="structR" class="id"><span id="structR.body" class="id"><span id="structR.unlock" class="id"><span id="structR_unlock_subterm" class="id">`{</span></span></span></span></span></span></span></a><a id="eb9571817dd417966f307c3a9de8fe7f" class="idref" href="#eb9571817dd417966f307c3a9de8fe7f"><span class="id" title="axiom, binder, definition, module"><span id="2ab75602e9b8af2ca6fd6dbdb1e68a19" class="id"><span id="structR_Locked" class="id"><span id="structR_Locked.body" class="id"><span id="structR_Locked.unlock" class="id"><span id="structR" class="id"><span id="structR.body" class="id"><span id="structR.unlock" class="id"><span id="structR_unlock_subterm" class="id">Σ</span></span></span></span></span></span></span></span></span></a> <a id="structR_Locked" class="idref" href="#structR_Locked"><span class="id" title="axiom, definition, module"><span id="structR_Locked.body" class="id"><span id="structR_Locked.unlock" class="id"><span id="structR" class="id"><span id="structR.body" class="id"><span id="structR.unlock" class="id"><span id="structR_unlock_subterm" class="id">:</span></span></span></span></span></span></span></a> <a id="structR_Locked" class="idref" href="#structR_Locked"><span class="id" title="axiom, definition, module"><span id="structR_Locked.body" class="id"><span id="structR_Locked.unlock" class="id"><span id="structR" class="id"><span id="structR.body" class="id"><span id="structR.unlock" class="id"><span id="structR_unlock_subterm" class="id">cpp_logic</span></span></span></span></span></span></span></a><a id="structR_Locked" class="idref" href="#structR_Locked"><span class="id" title="axiom, definition, module"><span id="structR_Locked.body" class="id"><span id="structR_Locked.unlock" class="id"><span id="structR" class="id"><span id="structR.body" class="id"><span id="structR.unlock" class="id"><span id="structR_unlock_subterm" class="id">}</span></span></span></span></span></span></span></a> <a id="structR_Locked" class="idref" href="#structR_Locked"><span class="id" title="axiom, definition, module"><span id="structR_Locked.body" class="id"><span id="structR_Locked.unlock" class="id"><span id="structR" class="id"><span id="structR.body" class="id"><span id="structR.unlock" class="id"><span id="structR_unlock_subterm" class="id">{</span></span></span></span></span></span></span></a><a id="cd01c1f8eba18116122f50d6eb622af2" class="idref" href="#cd01c1f8eba18116122f50d6eb622af2"><span class="id" title="axiom, binder, definition, module"><span id="303c62d4b554442e1659318da8f8db12" class="id"><span id="structR_Locked" class="id"><span id="structR_Locked.body" class="id"><span id="structR_Locked.unlock" class="id"><span id="structR" class="id"><span id="structR.body" class="id"><span id="structR.unlock" class="id"><span id="structR_unlock_subterm" class="id">σ</span></span></span></span></span></span></span></span></span></a> <a id="structR_Locked" class="idref" href="#structR_Locked"><span class="id" title="axiom, definition, module"><span id="structR_Locked.body" class="id"><span id="structR_Locked.unlock" class="id"><span id="structR" class="id"><span id="structR.body" class="id"><span id="structR.unlock" class="id"><span id="structR_unlock_subterm" class="id">:</span></span></span></span></span></span></span></a> <a id="structR_Locked" class="idref" href="#structR_Locked"><span class="id" title="axiom, definition, module"><span id="structR_Locked.body" class="id"><span id="structR_Locked.unlock" class="id"><span id="structR" class="id"><span id="structR.body" class="id"><span id="structR.unlock" class="id"><span id="structR_unlock_subterm" class="id">genv</span></span></span></span></span></span></span></a><a id="structR_Locked" class="idref" href="#structR_Locked"><span class="id" title="axiom, definition, module"><span id="structR_Locked.body" class="id"><span id="structR_Locked.unlock" class="id"><span id="structR" class="id"><span id="structR.body" class="id"><span id="structR.unlock" class="id"><span id="structR_unlock_subterm" class="id">}</span></span></span></span></span></span></span></a> <a id="structR_Locked" class="idref" href="#structR_Locked"><span class="id" title="axiom, definition, module"><span id="structR_Locked.body" class="id"><span id="structR_Locked.unlock" class="id"><span id="structR" class="id"><span id="structR.body" class="id"><span id="structR.unlock" class="id"><span id="structR_unlock_subterm" class="id">(</span></span></span></span></span></span></span></a><a id="cls:5" class="idref" href="#cls:5"><span class="id" title="axiom, binder, definition, module"><span id="cls:12" class="id"><span id="structR_Locked" class="id"><span id="structR_Locked.body" class="id"><span id="structR_Locked.unlock" class="id"><span id="structR" class="id"><span id="structR.body" class="id"><span id="structR.unlock" class="id"><span id="structR_unlock_subterm" class="id">cls</span></span></span></span></span></span></span></span></span></a> <a id="structR_Locked" class="idref" href="#structR_Locked"><span class="id" title="axiom, definition, module"><span id="structR_Locked.body" class="id"><span id="structR_Locked.unlock" class="id"><span id="structR" class="id"><span id="structR.body" class="id"><span id="structR.unlock" class="id"><span id="structR_unlock_subterm" class="id">:</span></span></span></span></span></span></span></a> <a id="structR_Locked" class="idref" href="#structR_Locked"><span class="id" title="axiom, definition, module"><span id="structR_Locked.body" class="id"><span id="structR_Locked.unlock" class="id"><span id="structR" class="id"><span id="structR.body" class="id"><span id="structR.unlock" class="id"><span id="structR_unlock_subterm" class="id">globname</span></span></span></span></span></span></span></a><a id="structR_Locked" class="idref" href="#structR_Locked"><span class="id" title="axiom, definition, module"><span id="structR_Locked.body" class="id"><span id="structR_Locked.unlock" class="id"><span id="structR" class="id"><span id="structR.body" class="id"><span id="structR.unlock" class="id"><span id="structR_unlock_subterm" class="id">)</span></span></span></span></span></span></span></a> <a id="structR_Locked" class="idref" href="#structR_Locked"><span class="id" title="axiom, definition, module"><span id="structR_Locked.body" class="id"><span id="structR_Locked.unlock" class="id"><span id="structR" class="id"><span id="structR.body" class="id"><span id="structR.unlock" class="id"><span id="structR_unlock_subterm" class="id">(</span></span></span></span></span></span></span></a><a id="q:6" class="idref" href="#q:6"><span class="id" title="axiom, binder, definition, module"><span id="q:13" class="id"><span id="structR_Locked" class="id"><span id="structR_Locked.body" class="id"><span id="structR_Locked.unlock" class="id"><span id="structR" class="id"><span id="structR.body" class="id"><span id="structR.unlock" class="id"><span id="structR_unlock_subterm" class="id">q</span></span></span></span></span></span></span></span></span></a> <a id="structR_Locked" class="idref" href="#structR_Locked"><span class="id" title="axiom, definition, module"><span id="structR_Locked.body" class="id"><span id="structR_Locked.unlock" class="id"><span id="structR" class="id"><span id="structR.body" class="id"><span id="structR.unlock" class="id"><span id="structR_unlock_subterm" class="id">:</span></span></span></span></span></span></span></a> <a id="structR_Locked" class="idref" href="#structR_Locked"><span class="id" title="axiom, definition, module"><span id="structR_Locked.body" class="id"><span id="structR_Locked.unlock" class="id"><span id="structR" class="id"><span id="structR.body" class="id"><span id="structR.unlock" class="id"><span id="structR_unlock_subterm" class="id">cQp.t</span></span></span></span></span></span></span></a><a id="structR_Locked" class="idref" href="#structR_Locked"><span class="id" title="axiom, definition, module"><span id="structR_Locked.body" class="id"><span id="structR_Locked.unlock" class="id"><span id="structR" class="id"><span id="structR.body" class="id"><span id="structR.unlock" class="id"><span id="structR_unlock_subterm" class="id">)</span></span></span></span></span></span></span></a> <a id="structR_Locked" class="idref" href="#structR_Locked"><span class="id" title="axiom, definition, module"><span id="structR_Locked.body" class="id"><span id="structR_Locked.unlock" class="id"><span id="structR" class="id"><span id="structR.body" class="id"><span id="structR.unlock" class="id"><span id="structR_unlock_subterm" class="id">:</span></span></span></span></span></span></span></a> <a id="structR_Locked" class="idref" href="#structR_Locked"><span class="id" title="axiom, definition, module"><span id="structR_Locked.body" class="id"><span id="structR_Locked.unlock" class="id"><span id="structR" class="id"><span id="structR.body" class="id"><span id="structR.unlock" class="id"><span id="structR_unlock_subterm" class="id">Rep</span></span></span></span></span></span></span></a> <a id="structR_Locked" class="idref" href="#structR_Locked"><span class="id" title="axiom, definition, module"><span id="structR_Locked.body" class="id"><span id="structR_Locked.unlock" class="id"><span id="structR" class="id"><span id="structR.body" class="id"><span id="structR.unlock" class="id"><span id="structR_unlock_subterm" class="id">:=</span></span></span></span></span></span></span></a><br/>
&nbsp;&nbsp;<a id="structR_Locked" class="idref" href="#structR_Locked"><span class="id" title="axiom, definition, module"><span id="structR_Locked.body" class="id"><span id="structR_Locked.unlock" class="id"><span id="structR" class="id"><span id="structR.body" class="id"><span id="structR.unlock" class="id"><span id="structR_unlock_subterm" class="id">as_Rep</span></span></span></span></span></span></span></a> <a id="structR_Locked" class="idref" href="#structR_Locked"><span class="id" title="axiom, definition, module"><span id="structR_Locked.body" class="id"><span id="structR_Locked.unlock" class="id"><span id="structR" class="id"><span id="structR.body" class="id"><span id="structR.unlock" class="id"><span id="structR_unlock_subterm" class="id">(</span></span></span></span></span></span></span></a><a id="structR_Locked" class="idref" href="#structR_Locked"><span class="id" title="axiom, definition, module"><span id="structR_Locked.body" class="id"><span id="structR_Locked.unlock" class="id"><span id="structR" class="id"><span id="structR.body" class="id"><span id="structR.unlock" class="id"><span id="structR_unlock_subterm" class="id">fun</span></span></span></span></span></span></span></a> <a id="p:7" class="idref" href="#p:7"><span class="id" title="axiom, binder, definition, module"><span id="structR_Locked" class="id"><span id="structR_Locked.body" class="id"><span id="structR_Locked.unlock" class="id"><span id="structR" class="id"><span id="structR.body" class="id"><span id="structR.unlock" class="id"><span id="structR_unlock_subterm" class="id">p</span></span></span></span></span></span></span></span></a> <a id="structR_Locked" class="idref" href="#structR_Locked"><span class="id" title="axiom, definition, module"><span id="structR_Locked.body" class="id"><span id="structR_Locked.unlock" class="id"><span id="structR" class="id"><span id="structR.body" class="id"><span id="structR.unlock" class="id"><span id="structR_unlock_subterm" class="id">=&gt;</span></span></span></span></span></span></span></a> <a id="structR_Locked" class="idref" href="#structR_Locked"><span class="id" title="axiom, definition, module"><span id="structR_Locked.body" class="id"><span id="structR_Locked.unlock" class="id"><span id="structR" class="id"><span id="structR.body" class="id"><span id="structR.unlock" class="id"><span id="structR_unlock_subterm" class="id">struct_padding</span></span></span></span></span></span></span></a> <a id="structR_Locked" class="idref" href="#structR_Locked"><span class="id" title="axiom, definition, module"><span id="structR_Locked.body" class="id"><span id="structR_Locked.unlock" class="id"><span id="structR" class="id"><span id="structR.body" class="id"><span id="structR.unlock" class="id"><span id="structR_unlock_subterm" class="id">p</span></span></span></span></span></span></span></a> <a id="structR_Locked" class="idref" href="#structR_Locked"><span class="id" title="axiom, definition, module"><span id="structR_Locked.body" class="id"><span id="structR_Locked.unlock" class="id"><span id="structR" class="id"><span id="structR.body" class="id"><span id="structR.unlock" class="id"><span id="structR_unlock_subterm" class="id">cls</span></span></span></span></span></span></span></a> <a id="structR_Locked" class="idref" href="#structR_Locked"><span class="id" title="axiom, definition, module"><span id="structR_Locked.body" class="id"><span id="structR_Locked.unlock" class="id"><span id="structR" class="id"><span id="structR.body" class="id"><span id="structR.unlock" class="id"><span id="structR_unlock_subterm" class="id">q</span></span></span></span></span></span></span></a><a id="structR_Locked" class="idref" href="#structR_Locked"><span class="id" title="axiom, definition, module"><span id="structR_Locked.body" class="id"><span id="structR_Locked.unlock" class="id"><span id="structR" class="id"><span id="structR.body" class="id"><span id="structR.unlock" class="id"><span id="structR_unlock_subterm" class="id">)</span></span></span></span></span></span></span></a>.<br/>
#[<span class="id" title="var">global</span>] <span class="id" title="var">Arguments</span> <a class="idref" href="bedrock.lang.cpp.logic.heap_pred.aggregate.html#body"><span class="id" title="axiom">structR</span></a> {<span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">Σ</span> σ} <span class="id" title="var">cls</span> <span class="id" title="var">q</span> : <span class="id" title="tactic">assert</span>.<br/>

<br/>
<a id="unionR_Locked" class="idref" href="#unionR_Locked"><span class="id" title="axiom, definition, module"><span id="unionR_Locked.body" class="id"><span id="unionR_Locked.unlock" class="id"><span id="unionR" class="id"><span id="unionR.body" class="id"><span id="unionR.unlock" class="id"><span id="unionR_unlock_subterm" class="id">mlock</span></span></span></span></span></span></span></a><br/>
<a id="unionR_Locked" class="idref" href="#unionR_Locked"><span class="id" title="axiom, definition, module"><span id="unionR_Locked.body" class="id"><span id="unionR_Locked.unlock" class="id"><span id="unionR" class="id"><span id="unionR.body" class="id"><span id="unionR.unlock" class="id"><span id="unionR_unlock_subterm" class="id">Definition</span></span></span></span></span></span></span></a> <a id="unionR_Locked" class="idref" href="#unionR_Locked"><span class="id" title="axiom, definition, module"><span id="unionR_Locked.body" class="id"><span id="unionR_Locked.unlock" class="id"><span id="unionR" class="id"><span id="unionR.body" class="id"><span id="unionR.unlock" class="id"><span id="unionR_unlock_subterm" class="id">unionR</span></span></span></span></span></span></span></a> <a id="unionR_Locked" class="idref" href="#unionR_Locked"><span class="id" title="axiom, definition, module"><span id="unionR_Locked.body" class="id"><span id="unionR_Locked.unlock" class="id"><span id="unionR" class="id"><span id="unionR.body" class="id"><span id="unionR.unlock" class="id"><span id="unionR_unlock_subterm" class="id">`{</span></span></span></span></span></span></span></a><a id="b232edaf48a0ef1d98913dc1ee6186a9" class="idref" href="#b232edaf48a0ef1d98913dc1ee6186a9"><span class="id" title="axiom, binder, definition, module"><span id="0ff5eed445d72e1c5ccedcdae1755936" class="id"><span id="unionR_Locked" class="id"><span id="unionR_Locked.body" class="id"><span id="unionR_Locked.unlock" class="id"><span id="unionR" class="id"><span id="unionR.body" class="id"><span id="unionR.unlock" class="id"><span id="unionR_unlock_subterm" class="id">Σ</span></span></span></span></span></span></span></span></span></a> <a id="unionR_Locked" class="idref" href="#unionR_Locked"><span class="id" title="axiom, definition, module"><span id="unionR_Locked.body" class="id"><span id="unionR_Locked.unlock" class="id"><span id="unionR" class="id"><span id="unionR.body" class="id"><span id="unionR.unlock" class="id"><span id="unionR_unlock_subterm" class="id">:</span></span></span></span></span></span></span></a> <a id="unionR_Locked" class="idref" href="#unionR_Locked"><span class="id" title="axiom, definition, module"><span id="unionR_Locked.body" class="id"><span id="unionR_Locked.unlock" class="id"><span id="unionR" class="id"><span id="unionR.body" class="id"><span id="unionR.unlock" class="id"><span id="unionR_unlock_subterm" class="id">cpp_logic</span></span></span></span></span></span></span></a><a id="unionR_Locked" class="idref" href="#unionR_Locked"><span class="id" title="axiom, definition, module"><span id="unionR_Locked.body" class="id"><span id="unionR_Locked.unlock" class="id"><span id="unionR" class="id"><span id="unionR.body" class="id"><span id="unionR.unlock" class="id"><span id="unionR_unlock_subterm" class="id">}</span></span></span></span></span></span></span></a> <a id="unionR_Locked" class="idref" href="#unionR_Locked"><span class="id" title="axiom, definition, module"><span id="unionR_Locked.body" class="id"><span id="unionR_Locked.unlock" class="id"><span id="unionR" class="id"><span id="unionR.body" class="id"><span id="unionR.unlock" class="id"><span id="unionR_unlock_subterm" class="id">{</span></span></span></span></span></span></span></a><a id="0b62e00a8cabb8092988a5646f06f6ac" class="idref" href="#0b62e00a8cabb8092988a5646f06f6ac"><span class="id" title="axiom, binder, definition, module"><span id="671d6a60fe91a45440b15b3b4e49a57f" class="id"><span id="unionR_Locked" class="id"><span id="unionR_Locked.body" class="id"><span id="unionR_Locked.unlock" class="id"><span id="unionR" class="id"><span id="unionR.body" class="id"><span id="unionR.unlock" class="id"><span id="unionR_unlock_subterm" class="id">σ</span></span></span></span></span></span></span></span></span></a> <a id="unionR_Locked" class="idref" href="#unionR_Locked"><span class="id" title="axiom, definition, module"><span id="unionR_Locked.body" class="id"><span id="unionR_Locked.unlock" class="id"><span id="unionR" class="id"><span id="unionR.body" class="id"><span id="unionR.unlock" class="id"><span id="unionR_unlock_subterm" class="id">:</span></span></span></span></span></span></span></a> <a id="unionR_Locked" class="idref" href="#unionR_Locked"><span class="id" title="axiom, definition, module"><span id="unionR_Locked.body" class="id"><span id="unionR_Locked.unlock" class="id"><span id="unionR" class="id"><span id="unionR.body" class="id"><span id="unionR.unlock" class="id"><span id="unionR_unlock_subterm" class="id">genv</span></span></span></span></span></span></span></a><a id="unionR_Locked" class="idref" href="#unionR_Locked"><span class="id" title="axiom, definition, module"><span id="unionR_Locked.body" class="id"><span id="unionR_Locked.unlock" class="id"><span id="unionR" class="id"><span id="unionR.body" class="id"><span id="unionR.unlock" class="id"><span id="unionR_unlock_subterm" class="id">}</span></span></span></span></span></span></span></a> <a id="unionR_Locked" class="idref" href="#unionR_Locked"><span class="id" title="axiom, definition, module"><span id="unionR_Locked.body" class="id"><span id="unionR_Locked.unlock" class="id"><span id="unionR" class="id"><span id="unionR.body" class="id"><span id="unionR.unlock" class="id"><span id="unionR_unlock_subterm" class="id">(</span></span></span></span></span></span></span></a><a id="cls:18" class="idref" href="#cls:18"><span class="id" title="axiom, binder, definition, module"><span id="cls:26" class="id"><span id="unionR_Locked" class="id"><span id="unionR_Locked.body" class="id"><span id="unionR_Locked.unlock" class="id"><span id="unionR" class="id"><span id="unionR.body" class="id"><span id="unionR.unlock" class="id"><span id="unionR_unlock_subterm" class="id">cls</span></span></span></span></span></span></span></span></span></a> <a id="unionR_Locked" class="idref" href="#unionR_Locked"><span class="id" title="axiom, definition, module"><span id="unionR_Locked.body" class="id"><span id="unionR_Locked.unlock" class="id"><span id="unionR" class="id"><span id="unionR.body" class="id"><span id="unionR.unlock" class="id"><span id="unionR_unlock_subterm" class="id">:</span></span></span></span></span></span></span></a> <a id="unionR_Locked" class="idref" href="#unionR_Locked"><span class="id" title="axiom, definition, module"><span id="unionR_Locked.body" class="id"><span id="unionR_Locked.unlock" class="id"><span id="unionR" class="id"><span id="unionR.body" class="id"><span id="unionR.unlock" class="id"><span id="unionR_unlock_subterm" class="id">globname</span></span></span></span></span></span></span></a><a id="unionR_Locked" class="idref" href="#unionR_Locked"><span class="id" title="axiom, definition, module"><span id="unionR_Locked.body" class="id"><span id="unionR_Locked.unlock" class="id"><span id="unionR" class="id"><span id="unionR.body" class="id"><span id="unionR.unlock" class="id"><span id="unionR_unlock_subterm" class="id">)</span></span></span></span></span></span></span></a> <a id="unionR_Locked" class="idref" href="#unionR_Locked"><span class="id" title="axiom, definition, module"><span id="unionR_Locked.body" class="id"><span id="unionR_Locked.unlock" class="id"><span id="unionR" class="id"><span id="unionR.body" class="id"><span id="unionR.unlock" class="id"><span id="unionR_unlock_subterm" class="id">(</span></span></span></span></span></span></span></a><a id="q:19" class="idref" href="#q:19"><span class="id" title="axiom, binder, definition, module"><span id="q:27" class="id"><span id="unionR_Locked" class="id"><span id="unionR_Locked.body" class="id"><span id="unionR_Locked.unlock" class="id"><span id="unionR" class="id"><span id="unionR.body" class="id"><span id="unionR.unlock" class="id"><span id="unionR_unlock_subterm" class="id">q</span></span></span></span></span></span></span></span></span></a> <a id="unionR_Locked" class="idref" href="#unionR_Locked"><span class="id" title="axiom, definition, module"><span id="unionR_Locked.body" class="id"><span id="unionR_Locked.unlock" class="id"><span id="unionR" class="id"><span id="unionR.body" class="id"><span id="unionR.unlock" class="id"><span id="unionR_unlock_subterm" class="id">:</span></span></span></span></span></span></span></a> <a id="unionR_Locked" class="idref" href="#unionR_Locked"><span class="id" title="axiom, definition, module"><span id="unionR_Locked.body" class="id"><span id="unionR_Locked.unlock" class="id"><span id="unionR" class="id"><span id="unionR.body" class="id"><span id="unionR.unlock" class="id"><span id="unionR_unlock_subterm" class="id">cQp.t</span></span></span></span></span></span></span></a><a id="unionR_Locked" class="idref" href="#unionR_Locked"><span class="id" title="axiom, definition, module"><span id="unionR_Locked.body" class="id"><span id="unionR_Locked.unlock" class="id"><span id="unionR" class="id"><span id="unionR.body" class="id"><span id="unionR.unlock" class="id"><span id="unionR_unlock_subterm" class="id">)</span></span></span></span></span></span></span></a> <a id="unionR_Locked" class="idref" href="#unionR_Locked"><span class="id" title="axiom, definition, module"><span id="unionR_Locked.body" class="id"><span id="unionR_Locked.unlock" class="id"><span id="unionR" class="id"><span id="unionR.body" class="id"><span id="unionR.unlock" class="id"><span id="unionR_unlock_subterm" class="id">(</span></span></span></span></span></span></span></a><a id="i:20" class="idref" href="#i:20"><span class="id" title="axiom, binder, definition, module"><span id="i:28" class="id"><span id="unionR_Locked" class="id"><span id="unionR_Locked.body" class="id"><span id="unionR_Locked.unlock" class="id"><span id="unionR" class="id"><span id="unionR.body" class="id"><span id="unionR.unlock" class="id"><span id="unionR_unlock_subterm" class="id">i</span></span></span></span></span></span></span></span></span></a> <a id="unionR_Locked" class="idref" href="#unionR_Locked"><span class="id" title="axiom, definition, module"><span id="unionR_Locked.body" class="id"><span id="unionR_Locked.unlock" class="id"><span id="unionR" class="id"><span id="unionR.body" class="id"><span id="unionR.unlock" class="id"><span id="unionR_unlock_subterm" class="id">:</span></span></span></span></span></span></span></a> <a id="unionR_Locked" class="idref" href="#unionR_Locked"><span class="id" title="axiom, definition, module"><span id="unionR_Locked.body" class="id"><span id="unionR_Locked.unlock" class="id"><span id="unionR" class="id"><span id="unionR.body" class="id"><span id="unionR.unlock" class="id"><span id="unionR_unlock_subterm" class="id">option</span></span></span></span></span></span></span></a> <a id="unionR_Locked" class="idref" href="#unionR_Locked"><span class="id" title="axiom, definition, module"><span id="unionR_Locked.body" class="id"><span id="unionR_Locked.unlock" class="id"><span id="unionR" class="id"><span id="unionR.body" class="id"><span id="unionR.unlock" class="id"><span id="unionR_unlock_subterm" class="id">nat</span></span></span></span></span></span></span></a><a id="unionR_Locked" class="idref" href="#unionR_Locked"><span class="id" title="axiom, definition, module"><span id="unionR_Locked.body" class="id"><span id="unionR_Locked.unlock" class="id"><span id="unionR" class="id"><span id="unionR.body" class="id"><span id="unionR.unlock" class="id"><span id="unionR_unlock_subterm" class="id">)</span></span></span></span></span></span></span></a> <a id="unionR_Locked" class="idref" href="#unionR_Locked"><span class="id" title="axiom, definition, module"><span id="unionR_Locked.body" class="id"><span id="unionR_Locked.unlock" class="id"><span id="unionR" class="id"><span id="unionR.body" class="id"><span id="unionR.unlock" class="id"><span id="unionR_unlock_subterm" class="id">:</span></span></span></span></span></span></span></a> <a id="unionR_Locked" class="idref" href="#unionR_Locked"><span class="id" title="axiom, definition, module"><span id="unionR_Locked.body" class="id"><span id="unionR_Locked.unlock" class="id"><span id="unionR" class="id"><span id="unionR.body" class="id"><span id="unionR.unlock" class="id"><span id="unionR_unlock_subterm" class="id">Rep</span></span></span></span></span></span></span></a> <a id="unionR_Locked" class="idref" href="#unionR_Locked"><span class="id" title="axiom, definition, module"><span id="unionR_Locked.body" class="id"><span id="unionR_Locked.unlock" class="id"><span id="unionR" class="id"><span id="unionR.body" class="id"><span id="unionR.unlock" class="id"><span id="unionR_unlock_subterm" class="id">:=</span></span></span></span></span></span></span></a><br/>
&nbsp;&nbsp;<a id="unionR_Locked" class="idref" href="#unionR_Locked"><span class="id" title="axiom, definition, module"><span id="unionR_Locked.body" class="id"><span id="unionR_Locked.unlock" class="id"><span id="unionR" class="id"><span id="unionR.body" class="id"><span id="unionR.unlock" class="id"><span id="unionR_unlock_subterm" class="id">as_Rep</span></span></span></span></span></span></span></a> <a id="unionR_Locked" class="idref" href="#unionR_Locked"><span class="id" title="axiom, definition, module"><span id="unionR_Locked.body" class="id"><span id="unionR_Locked.unlock" class="id"><span id="unionR" class="id"><span id="unionR.body" class="id"><span id="unionR.unlock" class="id"><span id="unionR_unlock_subterm" class="id">(</span></span></span></span></span></span></span></a><a id="unionR_Locked" class="idref" href="#unionR_Locked"><span class="id" title="axiom, definition, module"><span id="unionR_Locked.body" class="id"><span id="unionR_Locked.unlock" class="id"><span id="unionR" class="id"><span id="unionR.body" class="id"><span id="unionR.unlock" class="id"><span id="unionR_unlock_subterm" class="id">fun</span></span></span></span></span></span></span></a> <a id="p:21" class="idref" href="#p:21"><span class="id" title="axiom, binder, definition, module"><span id="unionR_Locked" class="id"><span id="unionR_Locked.body" class="id"><span id="unionR_Locked.unlock" class="id"><span id="unionR" class="id"><span id="unionR.body" class="id"><span id="unionR.unlock" class="id"><span id="unionR_unlock_subterm" class="id">p</span></span></span></span></span></span></span></span></a> <a id="unionR_Locked" class="idref" href="#unionR_Locked"><span class="id" title="axiom, definition, module"><span id="unionR_Locked.body" class="id"><span id="unionR_Locked.unlock" class="id"><span id="unionR" class="id"><span id="unionR.body" class="id"><span id="unionR.unlock" class="id"><span id="unionR_unlock_subterm" class="id">=&gt;</span></span></span></span></span></span></span></a> <a id="unionR_Locked" class="idref" href="#unionR_Locked"><span class="id" title="axiom, definition, module"><span id="unionR_Locked.body" class="id"><span id="unionR_Locked.unlock" class="id"><span id="unionR" class="id"><span id="unionR.body" class="id"><span id="unionR.unlock" class="id"><span id="unionR_unlock_subterm" class="id">union_padding</span></span></span></span></span></span></span></a> <a id="unionR_Locked" class="idref" href="#unionR_Locked"><span class="id" title="axiom, definition, module"><span id="unionR_Locked.body" class="id"><span id="unionR_Locked.unlock" class="id"><span id="unionR" class="id"><span id="unionR.body" class="id"><span id="unionR.unlock" class="id"><span id="unionR_unlock_subterm" class="id">p</span></span></span></span></span></span></span></a> <a id="unionR_Locked" class="idref" href="#unionR_Locked"><span class="id" title="axiom, definition, module"><span id="unionR_Locked.body" class="id"><span id="unionR_Locked.unlock" class="id"><span id="unionR" class="id"><span id="unionR.body" class="id"><span id="unionR.unlock" class="id"><span id="unionR_unlock_subterm" class="id">cls</span></span></span></span></span></span></span></a> <a id="unionR_Locked" class="idref" href="#unionR_Locked"><span class="id" title="axiom, definition, module"><span id="unionR_Locked.body" class="id"><span id="unionR_Locked.unlock" class="id"><span id="unionR" class="id"><span id="unionR.body" class="id"><span id="unionR.unlock" class="id"><span id="unionR_unlock_subterm" class="id">q</span></span></span></span></span></span></span></a> <a id="unionR_Locked" class="idref" href="#unionR_Locked"><span class="id" title="axiom, definition, module"><span id="unionR_Locked.body" class="id"><span id="unionR_Locked.unlock" class="id"><span id="unionR" class="id"><span id="unionR.body" class="id"><span id="unionR.unlock" class="id"><span id="unionR_unlock_subterm" class="id">i</span></span></span></span></span></span></span></a><a id="unionR_Locked" class="idref" href="#unionR_Locked"><span class="id" title="axiom, definition, module"><span id="unionR_Locked.body" class="id"><span id="unionR_Locked.unlock" class="id"><span id="unionR" class="id"><span id="unionR.body" class="id"><span id="unionR.unlock" class="id"><span id="unionR_unlock_subterm" class="id">)</span></span></span></span></span></span></span></a>.<br/>
#[<span class="id" title="var">global</span>] <span class="id" title="var">Arguments</span> <a class="idref" href="bedrock.lang.cpp.logic.heap_pred.aggregate.html#body"><span class="id" title="axiom">unionR</span></a> {<span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">Σ</span> σ} <span class="id" title="var">cls</span> <span class="id" title="var">q</span> <span class="id" title="var">i</span> : <span class="id" title="tactic">assert</span>.<br/>

<br/>
<span class="id" title="keyword">Section</span> <a id="aggregate" class="idref" href="#aggregate"><span class="id" title="section">aggregate</span></a>.<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Context</span> `{<a id="7374d4818eab9c7e7a123322e5aab0bf" class="idref" href="#7374d4818eab9c7e7a123322e5aab0bf"><span class="id" title="binder">Σ</span></a> : <a class="idref" href="bedrock.lang.cpp.logic.mpred.html#LC.cpp_logic"><span class="id" title="class">cpp_logic</span></a>} {<a id="06b43d5b33f680f1c997e1fdb8d32e12" class="idref" href="#06b43d5b33f680f1c997e1fdb8d32e12"><span class="id" title="binder">σ</span></a> : <a class="idref" href="bedrock.lang.cpp.semantics.genv.html#genv"><span class="id" title="class">genv</span></a>}.<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Variable</span> <a id="aggregate.cls" class="idref" href="#aggregate.cls"><span class="id" title="variable">cls</span></a> : <a class="idref" href="bedrock.lang.cpp.syntax.names.html#globname"><span class="id" title="definition">globname</span></a>.<br/>

<br/>
&nbsp;&nbsp;#[<span class="id" title="var">global</span>] <span class="id" title="keyword">Instance</span> <a id="structR_fractional" class="idref" href="#structR_fractional"><span class="id" title="instance">structR_fractional</span></a> : <a class="idref" href="bedrock.lang.cpp.bi.cfractional.html#CFractional"><span class="id" title="class">CFractional</span></a> (<a class="idref" href="bedrock.lang.cpp.logic.heap_pred.aggregate.html#structR"><span class="id" title="abbreviation">structR</span></a> <a class="idref" href="bedrock.lang.cpp.logic.heap_pred.aggregate.html#aggregate.cls"><span class="id" title="variable">cls</span></a>).<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Proof</span>. <span class="id" title="tactic">rewrite</span> <a class="idref" href="bedrock.lang.cpp.logic.heap_pred.aggregate.html#unlock"><span class="id" title="axiom">structR.unlock</span></a>; <span class="id" title="tactic">eapply</span> <a class="idref" href="bedrock.lang.cpp.logic.rep.html#as_Rep_cfractional"><span class="id" title="instance">as_Rep_cfractional</span></a> =&gt; ?; <span class="id" title="tactic">eapply</span> <a class="idref" href="bedrock.lang.cpp.logic.pred.html#L.struct_padding_fractional"><span class="id" title="axiom">struct_padding_fractional</span></a>. <span class="id" title="keyword">Qed</span>.<br/>
&nbsp;&nbsp;#[<span class="id" title="var">global</span>] <span class="id" title="keyword">Instance</span> <a id="structR_cfractional_eta" class="idref" href="#structR_cfractional_eta"><span class="id" title="instance">structR_cfractional_eta</span></a> : <a class="idref" href="bedrock.lang.cpp.bi.cfractional.html#CFractional"><span class="id" title="class">CFractional</span></a> (<span class="id" title="keyword">fun</span> <a id="q:34" class="idref" href="#q:34"><span class="id" title="binder">q</span></a> =&gt; <a class="idref" href="bedrock.lang.cpp.logic.heap_pred.aggregate.html#structR"><span class="id" title="abbreviation">structR</span></a> <a class="idref" href="bedrock.lang.cpp.logic.heap_pred.aggregate.html#aggregate.cls"><span class="id" title="variable">cls</span></a> <a class="idref" href="bedrock.lang.cpp.logic.heap_pred.aggregate.html#q:34"><span class="id" title="variable">q</span></a>).<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Proof</span>. <span class="id" title="tactic">apply</span> <a class="idref" href="bedrock.lang.cpp.logic.heap_pred.aggregate.html#structR_fractional"><span class="id" title="instance">structR_fractional</span></a>. <span class="id" title="keyword">Qed</span>.<br/>

<br/>
&nbsp;&nbsp;#[<span class="id" title="var">global</span>] <span class="id" title="keyword">Instance</span> <a id="structR_timeless" class="idref" href="#structR_timeless"><span class="id" title="instance">structR_timeless</span></a> : <a class="idref" href="bedrock.lang.bi.derived_laws.html#nary.Timeless2"><span class="id" title="abbreviation">Timeless2</span></a> <a class="idref" href="bedrock.lang.cpp.logic.heap_pred.aggregate.html#structR"><span class="id" title="abbreviation">structR</span></a>.<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Proof</span>. <span class="id" title="tactic">rewrite</span> <a class="idref" href="bedrock.lang.cpp.logic.heap_pred.aggregate.html#unlock"><span class="id" title="axiom">structR.unlock</span></a>; <span class="id" title="tactic">apply</span> <span class="id" title="var">_</span>. <span class="id" title="keyword">Qed</span>.<br/>
&nbsp;&nbsp;#[<span class="id" title="var">global</span>] <span class="id" title="keyword">Instance</span> <a id="structR_frac_valid" class="idref" href="#structR_frac_valid"><span class="id" title="instance">structR_frac_valid</span></a> : <a class="idref" href="bedrock.lang.cpp.bi.cfractional.html#CFracValid0"><span class="id" title="class">CFracValid0</span></a> (<a class="idref" href="bedrock.lang.cpp.logic.heap_pred.aggregate.html#structR"><span class="id" title="abbreviation">structR</span></a> <a class="idref" href="bedrock.lang.cpp.logic.heap_pred.aggregate.html#aggregate.cls"><span class="id" title="variable">cls</span></a>).<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Proof</span>. <span class="id" title="tactic">rewrite</span> <a class="idref" href="bedrock.lang.cpp.logic.heap_pred.aggregate.html#unlock"><span class="id" title="axiom">structR.unlock</span></a>. <span class="id" title="tactic">constructor</span>. <span class="id" title="tactic">intros</span>; <span class="id" title="tactic">apply</span> <a class="idref" href="bedrock.lang.cpp.logic.rep.html#as_Rep_only_provable_observe"><span class="id" title="instance">as_Rep_only_provable_observe</span></a>. <span class="id" title="tactic">refine</span> <span class="id" title="var">_</span>. <span class="id" title="keyword">Qed</span>.<br/>
&nbsp;&nbsp;#[<span class="id" title="var">global</span>] <span class="id" title="keyword">Instance</span> <a id="structR_frac_valid_eta" class="idref" href="#structR_frac_valid_eta"><span class="id" title="instance">structR_frac_valid_eta</span></a> : <a class="idref" href="bedrock.lang.cpp.bi.cfractional.html#CFracValid0"><span class="id" title="class">CFracValid0</span></a> (<span class="id" title="keyword">fun</span> <a id="q:35" class="idref" href="#q:35"><span class="id" title="binder">q</span></a> =&gt; <a class="idref" href="bedrock.lang.cpp.logic.heap_pred.aggregate.html#structR"><span class="id" title="abbreviation">structR</span></a> <a class="idref" href="bedrock.lang.cpp.logic.heap_pred.aggregate.html#aggregate.cls"><span class="id" title="variable">cls</span></a> <a class="idref" href="bedrock.lang.cpp.logic.heap_pred.aggregate.html#q:35"><span class="id" title="variable">q</span></a>).<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Proof</span>. <span class="id" title="tactic">apply</span> <a class="idref" href="bedrock.lang.cpp.logic.heap_pred.aggregate.html#structR_frac_valid"><span class="id" title="instance">structR_frac_valid</span></a>. <span class="id" title="keyword">Qed</span>.<br/>

<br/>
&nbsp;&nbsp;#[<span class="id" title="var">global</span>] <span class="id" title="keyword">Instance</span> <a id="structR_as_fractional" class="idref" href="#structR_as_fractional"><span class="id" title="instance">structR_as_fractional</span></a> : <a class="idref" href="bedrock.lang.cpp.bi.cfractional.html#AsCFractional0"><span class="id" title="abbreviation">AsCFractional0</span></a> (<a class="idref" href="bedrock.lang.cpp.logic.heap_pred.aggregate.html#structR"><span class="id" title="abbreviation">structR</span></a> <a class="idref" href="bedrock.lang.cpp.logic.heap_pred.aggregate.html#aggregate.cls"><span class="id" title="variable">cls</span></a>).<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Proof</span>. <span class="id" title="var">solve_as_cfrac</span>. <span class="id" title="keyword">Qed</span>.<br/>

<br/>
&nbsp;&nbsp;#[<span class="id" title="var">global</span>] <span class="id" title="keyword">Instance</span> <a id="union_fractional" class="idref" href="#union_fractional"><span class="id" title="instance">union_fractional</span></a> : <a class="idref" href="bedrock.lang.cpp.bi.cfractional.html#CFractional1"><span class="id" title="abbreviation">CFractional1</span></a> (<a class="idref" href="bedrock.lang.cpp.logic.heap_pred.aggregate.html#unionR"><span class="id" title="abbreviation">unionR</span></a> <a class="idref" href="bedrock.lang.cpp.logic.heap_pred.aggregate.html#aggregate.cls"><span class="id" title="variable">cls</span></a>).<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Proof</span>. <span class="id" title="tactic">rewrite</span> <a class="idref" href="bedrock.lang.cpp.logic.heap_pred.aggregate.html#unlock"><span class="id" title="axiom">unionR.unlock</span></a>; <span class="id" title="tactic">intros</span>; <span class="id" title="tactic">eapply</span> <a class="idref" href="bedrock.lang.cpp.logic.rep.html#as_Rep_cfractional"><span class="id" title="instance">as_Rep_cfractional</span></a> =&gt; ?; <span class="id" title="tactic">eapply</span> <a class="idref" href="bedrock.lang.cpp.logic.pred.html#L.union_padding_fractional"><span class="id" title="axiom">union_padding_fractional</span></a>. <span class="id" title="keyword">Qed</span>.<br/>
&nbsp;&nbsp;#[<span class="id" title="var">global</span>] <span class="id" title="keyword">Instance</span> <a id="union_timeless" class="idref" href="#union_timeless"><span class="id" title="instance">union_timeless</span></a> : <a class="idref" href="bedrock.lang.bi.derived_laws.html#nary.Timeless3"><span class="id" title="abbreviation">Timeless3</span></a> <a class="idref" href="bedrock.lang.cpp.logic.heap_pred.aggregate.html#unionR"><span class="id" title="abbreviation">unionR</span></a>.<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Proof</span>. <span class="id" title="tactic">rewrite</span> <a class="idref" href="bedrock.lang.cpp.logic.heap_pred.aggregate.html#unlock"><span class="id" title="axiom">unionR.unlock</span></a>; <span class="id" title="tactic">apply</span> <span class="id" title="var">_</span>. <span class="id" title="keyword">Qed</span>.<br/>
&nbsp;&nbsp;#[<span class="id" title="var">global</span>] <span class="id" title="keyword">Instance</span> <a id="union_frac_valid" class="idref" href="#union_frac_valid"><span class="id" title="instance">union_frac_valid</span></a> : <a class="idref" href="bedrock.lang.cpp.bi.cfractional.html#CFracValid1"><span class="id" title="class">CFracValid1</span></a> (<a class="idref" href="bedrock.lang.cpp.logic.heap_pred.aggregate.html#unionR"><span class="id" title="abbreviation">unionR</span></a> <a class="idref" href="bedrock.lang.cpp.logic.heap_pred.aggregate.html#aggregate.cls"><span class="id" title="variable">cls</span></a>).<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Proof</span>. <span class="id" title="tactic">rewrite</span> <a class="idref" href="bedrock.lang.cpp.logic.heap_pred.aggregate.html#unlock"><span class="id" title="axiom">unionR.unlock</span></a>. <span class="id" title="tactic">constructor</span>. <span class="id" title="tactic">intros</span>; <span class="id" title="tactic">apply</span> <a class="idref" href="bedrock.lang.cpp.logic.rep.html#as_Rep_only_provable_observe"><span class="id" title="instance">as_Rep_only_provable_observe</span></a>. <span class="id" title="tactic">refine</span> <span class="id" title="var">_</span>. <span class="id" title="keyword">Qed</span>.<br/>

<br/>
&nbsp;&nbsp;#[<span class="id" title="var">global</span>] <span class="id" title="keyword">Instance</span> <a id="union_as_fractional" class="idref" href="#union_as_fractional"><span class="id" title="instance">union_as_fractional</span></a> : <a class="idref" href="bedrock.lang.cpp.bi.cfractional.html#AsCFractional1"><span class="id" title="abbreviation">AsCFractional1</span></a> (<a class="idref" href="bedrock.lang.cpp.logic.heap_pred.aggregate.html#unionR"><span class="id" title="abbreviation">unionR</span></a> <a class="idref" href="bedrock.lang.cpp.logic.heap_pred.aggregate.html#aggregate.cls"><span class="id" title="variable">cls</span></a>).<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Proof</span>. <span class="id" title="var">solve_as_cfrac</span>. <span class="id" title="keyword">Qed</span>.<br/>

<br/>
&nbsp;&nbsp;#[<span class="id" title="var">global</span>] <span class="id" title="keyword">Instance</span> <a id="structR_type_ptr_observe" class="idref" href="#structR_type_ptr_observe"><span class="id" title="instance">structR_type_ptr_observe</span></a> : <a class="idref" href="https://plv.mpi-sws.org/coqdoc/stdpp//stdpp.base.html#a46514f7419edb3d22453078cf7c9fb7"><span class="id" title="notation">forall</span></a> <a id="q:36" class="idref" href="#q:36"><span class="id" title="binder">q</span></a> <a id="cls:37" class="idref" href="#cls:37"><span class="id" title="binder">cls</span></a><a class="idref" href="https://plv.mpi-sws.org/coqdoc/stdpp//stdpp.base.html#a46514f7419edb3d22453078cf7c9fb7"><span class="id" title="notation">,</span></a> <a class="idref" href="bedrock.lang.bi.observe.html#Observe"><span class="id" title="class">Observe</span></a> (<a class="idref" href="bedrock.lang.cpp.logic.heap_pred.valid.html#type_ptrR"><span class="id" title="definition">type_ptrR</span></a> (<a class="idref" href="bedrock.lang.cpp.syntax.types.html#Tnamed"><span class="id" title="constructor">Tnamed</span></a> <a class="idref" href="bedrock.lang.cpp.logic.heap_pred.aggregate.html#cls:37"><span class="id" title="variable">cls</span></a>)) (<a class="idref" href="bedrock.lang.cpp.logic.heap_pred.aggregate.html#structR"><span class="id" title="abbreviation">structR</span></a> <a class="idref" href="bedrock.lang.cpp.logic.heap_pred.aggregate.html#cls:37"><span class="id" title="variable">cls</span></a> <a class="idref" href="bedrock.lang.cpp.logic.heap_pred.aggregate.html#q:36"><span class="id" title="variable">q</span></a>).<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">intros</span>; <span class="id" title="tactic">eapply</span> <a class="idref" href="bedrock.lang.cpp.logic.rep.html#observe_at"><span class="id" title="lemma">observe_at</span></a>; <span class="id" title="tactic">intros</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> <a class="idref" href="bedrock.lang.cpp.logic.heap_pred.valid.html#_at_type_ptrR"><span class="id" title="lemma">_at_type_ptrR</span></a> <a class="idref" href="bedrock.lang.cpp.logic.heap_pred.aggregate.html#unlock"><span class="id" title="axiom">structR.unlock</span></a> <a class="idref" href="bedrock.lang.cpp.logic.rep.html#_at_as_Rep"><span class="id" title="lemma">_at_as_Rep</span></a>. <span class="id" title="tactic">refine</span> <span class="id" title="var">_</span>.<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Qed</span>.<br/>
&nbsp;&nbsp;#[<span class="id" title="var">global</span>] <span class="id" title="keyword">Instance</span> <a id="structR_strict_valid_observe" class="idref" href="#structR_strict_valid_observe"><span class="id" title="instance">structR_strict_valid_observe</span></a> <a id="q:38" class="idref" href="#q:38"><span class="id" title="binder">q</span></a> : <a class="idref" href="bedrock.lang.bi.observe.html#Observe"><span class="id" title="class">Observe</span></a> <a class="idref" href="bedrock.lang.cpp.logic.heap_pred.valid.html#svalidR"><span class="id" title="definition">svalidR</span></a> (<a class="idref" href="bedrock.lang.cpp.logic.heap_pred.aggregate.html#structR"><span class="id" title="abbreviation">structR</span></a> <a class="idref" href="bedrock.lang.cpp.logic.heap_pred.aggregate.html#aggregate.cls"><span class="id" title="variable">cls</span></a> <a class="idref" href="bedrock.lang.cpp.logic.heap_pred.aggregate.html#q:38"><span class="id" title="variable">q</span></a>).<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Proof</span>. <span class="id" title="tactic">rewrite</span> -<a class="idref" href="bedrock.lang.cpp.logic.heap_pred.valid.html#type_ptrR_svalidR"><span class="id" title="lemma">type_ptrR_svalidR</span></a>; <span class="id" title="tactic">apply</span> <span class="id" title="var">_</span>. <span class="id" title="keyword">Qed</span>.<br/>
&nbsp;&nbsp;#[<span class="id" title="var">global</span>] <span class="id" title="keyword">Instance</span> <a id="structR_valid_observe" class="idref" href="#structR_valid_observe"><span class="id" title="instance">structR_valid_observe</span></a> <a id="q:39" class="idref" href="#q:39"><span class="id" title="binder">q</span></a> : <a class="idref" href="bedrock.lang.bi.observe.html#Observe"><span class="id" title="class">Observe</span></a> <a class="idref" href="bedrock.lang.cpp.logic.heap_pred.valid.html#validR"><span class="id" title="definition">validR</span></a> (<a class="idref" href="bedrock.lang.cpp.logic.heap_pred.aggregate.html#structR"><span class="id" title="abbreviation">structR</span></a> <a class="idref" href="bedrock.lang.cpp.logic.heap_pred.aggregate.html#aggregate.cls"><span class="id" title="variable">cls</span></a> <a class="idref" href="bedrock.lang.cpp.logic.heap_pred.aggregate.html#q:39"><span class="id" title="variable">q</span></a>).<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Proof</span>. <span class="id" title="tactic">rewrite</span> -<a class="idref" href="bedrock.lang.cpp.logic.heap_pred.valid.html#svalidR_validR"><span class="id" title="lemma">svalidR_validR</span></a>; <span class="id" title="tactic">apply</span> <span class="id" title="var">_</span>. <span class="id" title="keyword">Qed</span>.<br/>

<br/>
&nbsp;&nbsp;#[<span class="id" title="var">global</span>] <span class="id" title="keyword">Instance</span> <a id="structR_nonnull" class="idref" href="#structR_nonnull"><span class="id" title="instance">structR_nonnull</span></a> <a id="q:40" class="idref" href="#q:40"><span class="id" title="binder">q</span></a> : <a class="idref" href="bedrock.lang.bi.observe.html#Observe"><span class="id" title="class">Observe</span></a> <a class="idref" href="bedrock.lang.cpp.logic.heap_pred.null.html#nonnullR"><span class="id" title="abbreviation">nonnullR</span></a> (<a class="idref" href="bedrock.lang.cpp.logic.heap_pred.aggregate.html#structR"><span class="id" title="abbreviation">structR</span></a> <a class="idref" href="bedrock.lang.cpp.logic.heap_pred.aggregate.html#aggregate.cls"><span class="id" title="variable">cls</span></a> <a class="idref" href="bedrock.lang.cpp.logic.heap_pred.aggregate.html#q:40"><span class="id" title="variable">q</span></a>).<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">iIntros</span> "H".<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">iDestruct</span> <a class="idref" href="https://plv.mpi-sws.org/coqdoc/iris//iris.proofmode.ltac_tactics.html#c65a9d4b357f2165cc71fe44c81db669"><span class="id" title="notation">(</span></a><a class="idref" href="bedrock.lang.bi.observe.html#observe"><span class="id" title="definition">observe</span></a> (<a class="idref" href="bedrock.lang.cpp.logic.heap_pred.valid.html#type_ptrR"><span class="id" title="definition">type_ptrR</span></a> <span class="id" title="var">_</span>) <a class="idref" href="https://plv.mpi-sws.org/coqdoc/iris//iris.proofmode.ltac_tactics.html#c65a9d4b357f2165cc71fe44c81db669"><span class="id" title="notation">with</span></a> "H"<a class="idref" href="https://plv.mpi-sws.org/coqdoc/iris//iris.proofmode.ltac_tactics.html#c65a9d4b357f2165cc71fe44c81db669"><span class="id" title="notation">)</span></a> <span class="id" title="keyword">as</span> "#T".<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">iApply</span> <a class="idref" href="https://plv.mpi-sws.org/coqdoc/iris//iris.proofmode.ltac_tactics.html#c65a9d4b357f2165cc71fe44c81db669"><span class="id" title="notation">(</span></a><a class="idref" href="bedrock.lang.bi.observe.html#observe"><span class="id" title="definition">observe</span></a> <a class="idref" href="https://plv.mpi-sws.org/coqdoc/iris//iris.proofmode.ltac_tactics.html#c65a9d4b357f2165cc71fe44c81db669"><span class="id" title="notation">with</span></a> "T"<a class="idref" href="https://plv.mpi-sws.org/coqdoc/iris//iris.proofmode.ltac_tactics.html#c65a9d4b357f2165cc71fe44c81db669"><span class="id" title="notation">)</span></a>.<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Qed</span>.<br/>

<br/>
&nbsp;&nbsp;#[<span class="id" title="var">global</span>] <span class="id" title="keyword">Instance</span> <a id="unionR_type_ptr_observe" class="idref" href="#unionR_type_ptr_observe"><span class="id" title="instance">unionR_type_ptr_observe</span></a> : <a class="idref" href="https://plv.mpi-sws.org/coqdoc/stdpp//stdpp.base.html#a46514f7419edb3d22453078cf7c9fb7"><span class="id" title="notation">forall</span></a> <a id="q:41" class="idref" href="#q:41"><span class="id" title="binder">q</span></a> <a id="i:42" class="idref" href="#i:42"><span class="id" title="binder">i</span></a><a class="idref" href="https://plv.mpi-sws.org/coqdoc/stdpp//stdpp.base.html#a46514f7419edb3d22453078cf7c9fb7"><span class="id" title="notation">,</span></a> <a class="idref" href="bedrock.lang.bi.observe.html#Observe"><span class="id" title="class">Observe</span></a> (<a class="idref" href="bedrock.lang.cpp.logic.heap_pred.valid.html#type_ptrR"><span class="id" title="definition">type_ptrR</span></a> (<a class="idref" href="bedrock.lang.cpp.syntax.types.html#Tnamed"><span class="id" title="constructor">Tnamed</span></a> <a class="idref" href="bedrock.lang.cpp.logic.heap_pred.aggregate.html#aggregate.cls"><span class="id" title="variable">cls</span></a>)) (<a class="idref" href="bedrock.lang.cpp.logic.heap_pred.aggregate.html#unionR"><span class="id" title="abbreviation">unionR</span></a> <a class="idref" href="bedrock.lang.cpp.logic.heap_pred.aggregate.html#aggregate.cls"><span class="id" title="variable">cls</span></a> <a class="idref" href="bedrock.lang.cpp.logic.heap_pred.aggregate.html#q:41"><span class="id" title="variable">q</span></a> <a class="idref" href="bedrock.lang.cpp.logic.heap_pred.aggregate.html#i:42"><span class="id" title="variable">i</span></a>).<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">intros</span>; <span class="id" title="tactic">eapply</span> <a class="idref" href="bedrock.lang.cpp.logic.rep.html#observe_at"><span class="id" title="lemma">observe_at</span></a>; <span class="id" title="tactic">intros</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> <a class="idref" href="bedrock.lang.cpp.logic.heap_pred.valid.html#_at_type_ptrR"><span class="id" title="lemma">_at_type_ptrR</span></a> <a class="idref" href="bedrock.lang.cpp.logic.heap_pred.aggregate.html#unlock"><span class="id" title="axiom">unionR.unlock</span></a> <a class="idref" href="bedrock.lang.cpp.logic.rep.html#_at_as_Rep"><span class="id" title="lemma">_at_as_Rep</span></a>. <span class="id" title="tactic">refine</span> <span class="id" title="var">_</span>.<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Qed</span>.<br/>
&nbsp;&nbsp;#[<span class="id" title="var">global</span>] <span class="id" title="keyword">Instance</span> <a id="unionR_strict_valid_observe" class="idref" href="#unionR_strict_valid_observe"><span class="id" title="instance">unionR_strict_valid_observe</span></a> <a id="q:43" class="idref" href="#q:43"><span class="id" title="binder">q</span></a> <a id="i:44" class="idref" href="#i:44"><span class="id" title="binder">i</span></a> : <a class="idref" href="bedrock.lang.bi.observe.html#Observe"><span class="id" title="class">Observe</span></a> <a class="idref" href="bedrock.lang.cpp.logic.heap_pred.valid.html#svalidR"><span class="id" title="definition">svalidR</span></a> (<a class="idref" href="bedrock.lang.cpp.logic.heap_pred.aggregate.html#unionR"><span class="id" title="abbreviation">unionR</span></a> <a class="idref" href="bedrock.lang.cpp.logic.heap_pred.aggregate.html#aggregate.cls"><span class="id" title="variable">cls</span></a> <a class="idref" href="bedrock.lang.cpp.logic.heap_pred.aggregate.html#q:43"><span class="id" title="variable">q</span></a> <a class="idref" href="bedrock.lang.cpp.logic.heap_pred.aggregate.html#i:44"><span class="id" title="variable">i</span></a>).<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Proof</span>. <span class="id" title="tactic">rewrite</span> -<a class="idref" href="bedrock.lang.cpp.logic.heap_pred.valid.html#type_ptrR_svalidR"><span class="id" title="lemma">type_ptrR_svalidR</span></a>; <span class="id" title="tactic">apply</span> <span class="id" title="var">_</span>. <span class="id" title="keyword">Qed</span>.<br/>
&nbsp;&nbsp;#[<span class="id" title="var">global</span>] <span class="id" title="keyword">Instance</span> <a id="unionR_valid_observe" class="idref" href="#unionR_valid_observe"><span class="id" title="instance">unionR_valid_observe</span></a> <a id="q:45" class="idref" href="#q:45"><span class="id" title="binder">q</span></a> <a id="i:46" class="idref" href="#i:46"><span class="id" title="binder">i</span></a> : <a class="idref" href="bedrock.lang.bi.observe.html#Observe"><span class="id" title="class">Observe</span></a> <a class="idref" href="bedrock.lang.cpp.logic.heap_pred.valid.html#validR"><span class="id" title="definition">validR</span></a> (<a class="idref" href="bedrock.lang.cpp.logic.heap_pred.aggregate.html#unionR"><span class="id" title="abbreviation">unionR</span></a> <a class="idref" href="bedrock.lang.cpp.logic.heap_pred.aggregate.html#aggregate.cls"><span class="id" title="variable">cls</span></a> <a class="idref" href="bedrock.lang.cpp.logic.heap_pred.aggregate.html#q:45"><span class="id" title="variable">q</span></a> <a class="idref" href="bedrock.lang.cpp.logic.heap_pred.aggregate.html#i:46"><span class="id" title="variable">i</span></a>).<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Proof</span>. <span class="id" title="tactic">rewrite</span> -<a class="idref" href="bedrock.lang.cpp.logic.heap_pred.valid.html#svalidR_validR"><span class="id" title="lemma">svalidR_validR</span></a>; <span class="id" title="tactic">apply</span> <span class="id" title="var">_</span>. <span class="id" title="keyword">Qed</span>.<br/>

<br/>
&nbsp;&nbsp;#[<span class="id" title="var">global</span>] <span class="id" title="keyword">Instance</span> <a id="unionR_nonnull" class="idref" href="#unionR_nonnull"><span class="id" title="instance">unionR_nonnull</span></a> <a id="q:47" class="idref" href="#q:47"><span class="id" title="binder">q</span></a> <a id="i:48" class="idref" href="#i:48"><span class="id" title="binder">i</span></a> : <a class="idref" href="bedrock.lang.bi.observe.html#Observe"><span class="id" title="class">Observe</span></a> <a class="idref" href="bedrock.lang.cpp.logic.heap_pred.null.html#nonnullR"><span class="id" title="abbreviation">nonnullR</span></a> (<a class="idref" href="bedrock.lang.cpp.logic.heap_pred.aggregate.html#unionR"><span class="id" title="abbreviation">unionR</span></a> <a class="idref" href="bedrock.lang.cpp.logic.heap_pred.aggregate.html#aggregate.cls"><span class="id" title="variable">cls</span></a> <a class="idref" href="bedrock.lang.cpp.logic.heap_pred.aggregate.html#q:47"><span class="id" title="variable">q</span></a> <a class="idref" href="bedrock.lang.cpp.logic.heap_pred.aggregate.html#i:48"><span class="id" title="variable">i</span></a>).<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">iIntros</span> "H".<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">iDestruct</span> <a class="idref" href="https://plv.mpi-sws.org/coqdoc/iris//iris.proofmode.ltac_tactics.html#c65a9d4b357f2165cc71fe44c81db669"><span class="id" title="notation">(</span></a><a class="idref" href="bedrock.lang.bi.observe.html#observe"><span class="id" title="definition">observe</span></a> (<a class="idref" href="bedrock.lang.cpp.logic.heap_pred.valid.html#type_ptrR"><span class="id" title="definition">type_ptrR</span></a> <span class="id" title="var">_</span>) <a class="idref" href="https://plv.mpi-sws.org/coqdoc/iris//iris.proofmode.ltac_tactics.html#c65a9d4b357f2165cc71fe44c81db669"><span class="id" title="notation">with</span></a> "H"<a class="idref" href="https://plv.mpi-sws.org/coqdoc/iris//iris.proofmode.ltac_tactics.html#c65a9d4b357f2165cc71fe44c81db669"><span class="id" title="notation">)</span></a> <span class="id" title="keyword">as</span> "#T".<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">iApply</span> <a class="idref" href="https://plv.mpi-sws.org/coqdoc/iris//iris.proofmode.ltac_tactics.html#c65a9d4b357f2165cc71fe44c81db669"><span class="id" title="notation">(</span></a><a class="idref" href="bedrock.lang.bi.observe.html#observe"><span class="id" title="definition">observe</span></a> <a class="idref" href="https://plv.mpi-sws.org/coqdoc/iris//iris.proofmode.ltac_tactics.html#c65a9d4b357f2165cc71fe44c81db669"><span class="id" title="notation">with</span></a> "T"<a class="idref" href="https://plv.mpi-sws.org/coqdoc/iris//iris.proofmode.ltac_tactics.html#c65a9d4b357f2165cc71fe44c81db669"><span class="id" title="notation">)</span></a>.<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Qed</span>.<br/>

<br/>
&nbsp;&nbsp;#[<span class="id" title="var">global</span>] <span class="id" title="keyword">Instance</span> <a id="unionR_agree" class="idref" href="#unionR_agree"><span class="id" title="instance">unionR_agree</span></a> <a id="q:49" class="idref" href="#q:49"><span class="id" title="binder">q</span></a> <a id="q':50" class="idref" href="#q':50"><span class="id" title="binder">q'</span></a> <a id="i:51" class="idref" href="#i:51"><span class="id" title="binder">i</span></a> <a id="i':52" class="idref" href="#i':52"><span class="id" title="binder">i'</span></a> :<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="bedrock.lang.bi.observe.html#Observe2"><span class="id" title="class">Observe2</span></a> <a class="idref" href="bedrock.lang.bi.only_provable.html#d95ff2fe2904cc1067c71e0d017740c6"><span class="id" title="notation">[|</span></a> <a class="idref" href="bedrock.lang.cpp.logic.heap_pred.aggregate.html#i:51"><span class="id" title="variable">i</span></a> <a class="idref" href="http://coq.inria.fr/doc/V8.19.0/stdlib//Coq.Init.Logic.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="bedrock.lang.cpp.logic.heap_pred.aggregate.html#i':52"><span class="id" title="variable">i'</span></a> <a class="idref" href="bedrock.lang.bi.only_provable.html#d95ff2fe2904cc1067c71e0d017740c6"><span class="id" title="notation">|]</span></a> (<a class="idref" href="bedrock.lang.cpp.logic.heap_pred.aggregate.html#unionR"><span class="id" title="abbreviation">unionR</span></a> <a class="idref" href="bedrock.lang.cpp.logic.heap_pred.aggregate.html#aggregate.cls"><span class="id" title="variable">cls</span></a> <a class="idref" href="bedrock.lang.cpp.logic.heap_pred.aggregate.html#q:49"><span class="id" title="variable">q</span></a> <a class="idref" href="bedrock.lang.cpp.logic.heap_pred.aggregate.html#i:51"><span class="id" title="variable">i</span></a>) (<a class="idref" href="bedrock.lang.cpp.logic.heap_pred.aggregate.html#unionR"><span class="id" title="abbreviation">unionR</span></a> <a class="idref" href="bedrock.lang.cpp.logic.heap_pred.aggregate.html#aggregate.cls"><span class="id" title="variable">cls</span></a> <a class="idref" href="bedrock.lang.cpp.logic.heap_pred.aggregate.html#q':50"><span class="id" title="variable">q'</span></a> <a class="idref" href="bedrock.lang.cpp.logic.heap_pred.aggregate.html#i':52"><span class="id" title="variable">i'</span></a>).<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Proof</span>. <span class="id" title="tactic">rewrite</span> <a class="idref" href="bedrock.lang.cpp.logic.heap_pred.aggregate.html#unlock"><span class="id" title="axiom">unionR.unlock</span></a>. <span class="id" title="tactic">eapply</span> <a class="idref" href="bedrock.lang.cpp.logic.rep.html#observe_2_at"><span class="id" title="lemma">observe_2_at</span></a>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">intros</span>; <span class="id" title="tactic">rewrite</span> <a class="idref" href="bedrock.lang.cpp.logic.rep.html#_at_only_provable"><span class="id" title="lemma">_at_only_provable</span></a> !<a class="idref" href="bedrock.lang.cpp.logic.rep.html#_at_as_Rep"><span class="id" title="lemma">_at_as_Rep</span></a>. <span class="id" title="tactic">refine</span> <span class="id" title="var">_</span>.<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Qed</span>.<br/>

<br/>
<span class="id" title="keyword">End</span> <a class="idref" href="bedrock.lang.cpp.logic.heap_pred.aggregate.html#aggregate"><span class="id" title="section">aggregate</span></a>.<br/>
</div>
<!--
-- Copyright (c) 2020 BedRock Systems, Inc.
-- This software is distributed under the terms of the BedRock Open-Source License.
-- See the LICENSE-BedRock file in the repository root for details.
-->

<!--
-- SPDX-LIcense-Identifier:BSD-2-Clause
-->
</div>
<div id="footer">
  Generated by <a href="http://coq.inria.fr/">coqdoc</a> and improved with <a href="https://github.com/tebbi/coqdocjs">CoqdocJS</a>
</div>
</div>
</body>

</html>
