<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Evaluation &mdash; BedRock BRiCk alpha documentation</title>
      <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="_static/alectryon.css" type="text/css" />
      <link rel="stylesheet" href="_static/tango_subtle.min.css" type="text/css" />
      <link rel="stylesheet" href="_static/css/justify.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
        <script src="_static/jquery.js"></script>
        <script src="_static/underscore.js"></script>
        <script src="_static/doctools.js"></script>
        <script src="_static/alectryon.js"></script>
    <script src="_static/js/theme.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Undefined behavior and optimizations" href="undefined_behavior.html" />
    <link rel="prev" title="Language Support" href="features.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="index.html" class="icon icon-home"> BedRock BRiCk
          </a>
              <div class="version">
                0.5.0
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Table of Contents</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="features.html">Language Support</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Evaluation</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#expressions">Expressions</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#modeling-temporaries">Modeling Temporaries</a></li>
<li class="toctree-l3"><a class="reference internal" href="#l-values-x-values">l-values &amp; x-values</a></li>
<li class="toctree-l3"><a class="reference internal" href="#pr-values">pr-values</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#operands">Operands</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#function-call-semantics">Function Call Semantics</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="undefined_behavior.html">Undefined behavior and optimizations</a></li>
<li class="toctree-l1"><a class="reference internal" href="pointers.html">Pointers and pointer provenance</a></li>
<li class="toctree-l1"><a class="reference internal" href="object_layout.html">Object representation, layout and padding</a></li>
<li class="toctree-l1"><a class="reference internal" href="machine.html">Assembly Interoperation</a></li>
<li class="toctree-l1"><a class="reference internal" href="documentation.html">Code Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="proof_examples.html">Proof Examples</a></li>
<li class="toctree-l1"><a class="reference internal" href="bibliography.html">Related work and bibliography</a></li>
<li class="toctree-l1"><a class="reference internal" href="acknowledgements.html">Acknowledgements</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">BedRock BRiCk</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content style-external-links">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="index.html" class="icon icon-home"></a> &raquo;</li>
      <li>Evaluation</li>
      <li class="wy-breadcrumbs-aside">
            <a href="_sources/evaluation.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <div class="section" id="evaluation">
<span id="id1"></span><h1>Evaluation<a class="headerlink" href="#evaluation" title="Permalink to this headline"></a></h1>
<p>The semantics of C++ programs in BRiCk are written in <a class="reference external" href="https://en.wikipedia.org/wiki/Predicate_transformer_semantics">weakest (liberal) pre-condition style</a>.
The general form of these rules is the following:</p>
<p>Note that <code class="code highlight coq docutils literal notranslate"><span class="n"><span class="pre">wp</span></span></code> is a predicate in our separation logic (the fact that it returns a <code class="code highlight coq docutils literal notranslate"><span class="n"><span class="pre">PROP</span></span></code>).
Informally you can think of it as capturing the pre-condition to the inputs (one of which is normally an expression) that are sufficient such that the code is safe and if the expression terminates, it terminates in a state in which its outputs statisfy the “continuation” (i.e. the final function argument to <code class="code highlight coq docutils literal notranslate"><span class="n"><span class="pre">wp</span></span></code>).</p>
<p>Due to the structure of C++, BRiCk contains a separate weakest pre-condition modality for each syntactic category. These are defined in <a class="reference external" href="_static/coqdoc/bedrock.lang.cpp.logic.wp.html">bedrock.lang.cpp.logic.wp</a>.</p>
<div class="section" id="expressions">
<h2>Expressions<a class="headerlink" href="#expressions" title="Permalink to this headline"></a></h2>
<p>In BRiCk we break expression evaluation down into four weakest pre-condition assertions representing the different <a class="reference external" href="http://eel.is/c++draft/expr.prop#basic.lval-1">value categories</a> of a C++ expression.</p>
<div class="section" id="modeling-temporaries">
<h3>Modeling Temporaries<a class="headerlink" href="#modeling-temporaries" title="Permalink to this headline"></a></h3>
<p>In the course of evaluating C++ programs, the language can construct objects that are later destroyed, this occurs for <a class="reference external" href="https://eel.is/c++draft/basic.stc.auto#1">automatic storage duration</a> variables (i.e. stack allocated variables and temporaries).
C++ semantics guarantees that the lifetime of temporaries is well-bracketed, meaning that objects will be destroyed in the reverse order that they were constructed.
In BRiCk we capture the stack of objects to be destroyed using the type <a class="reference external" href="_static/coqdoc/bedrock.lang.cpp.logic.wp.html#FreeTemps.t">t</a>.</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>Inductive t : Type :=
| id (* = fun x =&gt; x *)
| delete (ty : type) (p : ptr) (* = delete_val ty p  *)
| delete_va (va : list (type * ptr)) (p : ptr)
| seq (f g : t) (* = fun x =&gt; f $ g x *)
| par (f g : t)
  (* = fun x =&gt; Exists Qf Qg, f Qf ** g Qg ** (Qf -* Qg -* x)
   *)
.
</pre></div>
</div>
<p>Here <a class="reference external" href="_static/coqdoc/bedrock.lang.cpp.logic.wp.html#FreeTemps.id">id</a> represents the identity, characterizing that nothing needs to be destroyed.
<code class="code highlight coq docutils literal notranslate"><span class="n"><span class="pre">delete</span></span> <span class="n"><span class="pre">ty</span></span> <span class="n"><span class="pre">p</span></span></code> represents that the value at pointer <code class="code highlight coq docutils literal notranslate"><span class="n"><span class="pre">p</span></span></code> (which should have type <code class="code highlight coq docutils literal notranslate"><span class="n"><span class="pre">ty</span></span></code>) needs to be destroyed.
Note that to delete the value, the C++ abstract machine runs the destructor and reclaims the underlying memory.
Note that virtual dispatch is <em>not</em> used when invoking the destructor.
<code class="code highlight coq docutils literal notranslate"><span class="n"><span class="pre">seq</span></span> <span class="n"><span class="pre">a</span></span> <span class="n"><span class="pre">b</span></span></code> means that the temporaries in <code class="code highlight coq docutils literal notranslate"><span class="n"><span class="pre">a</span></span></code> must be destroyed <em>before</em> the temporaries in <code class="code highlight coq docutils literal notranslate"><span class="n"><span class="pre">b</span></span></code>.
<code class="code highlight coq docutils literal notranslate"><span class="n"><span class="pre">par</span></span> <span class="n"><span class="pre">a</span></span> <span class="n"><span class="pre">b</span></span></code> means that the temporaries in <code class="code highlight coq docutils literal notranslate"><span class="n"><span class="pre">a</span></span></code> and the temporaries in <code class="code highlight coq docutils literal notranslate"><span class="n"><span class="pre">b</span></span></code> are destroyed in an interleaved manner <a class="footnote-reference brackets" href="#parallel-destruction" id="id2">1</a>.</p>
<p>The meaning of these constructs is made precise by interpreting the syntax using <a class="reference external" href="_static/coqdoc/bedrock.lang.cpp.logic.destroy.html#interp">interp</a>.</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>(** [interp free Q] &quot;runs&quot; [free] and then acts like [Q].

    NOTE this could directly support update modalities like regular [wp]s
         but in practice it is always going to occur at the end of a [wp] which
         means it will already have access to a fancy update.
 *)
Fixpoint interp (free : FreeTemps) (Q : epred) : mpred :=
  match free with
  | FreeTemps.id =&gt; Q
  | FreeTemps.seq f g =&gt; interp f $ interp g Q
  | FreeTemps.par f g =&gt; Exists Qf Qg, interp f Qf ** interp g Qg ** (Qf -* Qg -* Q)
  | FreeTemps.delete ty addr =&gt; destroy_val ty addr Q
  | FreeTemps.delete_va va addr =&gt; addr |-&gt; varargsR va ** Q
  end.
</pre></div>
</div>
</div>
<div class="section" id="l-values-x-values">
<h3>l-values &amp; x-values<a class="headerlink" href="#l-values-x-values" title="Permalink to this headline"></a></h3>
<p>l-values and x-values follow the same general structure.
Their weakest precondition rules are captured by <a class="reference external" href="_static/coqdoc/bedrock.lang.cpp.logic.wp.html#WPE.wp_lval">wp_lval</a> and <a class="reference external" href="_static/coqdoc/bedrock.lang.cpp.logic.wp.html#WPE.wp_xval">wp_xval</a> respectively (we show <code class="code highlight coq docutils literal notranslate"><span class="n"><span class="pre">wp_lval</span></span></code> as our example).</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>(* [wp_lval σ E ρ e Q] evaluates the expression [e] in region [ρ]
 * with mask [E] and continutation [Q].
 *)
Parameter wp_lval
  : forall {resolve:genv}, region -&gt;
      Expr -&gt;
      (ptr -&gt; FreeTemps -&gt; epred) -&gt; (* result -&gt; free -&gt; post *)
      mpred. (* pre-condition *)
</pre></div>
</div>
</div>
<div class="section" id="pr-values">
<h3>pr-values<a class="headerlink" href="#pr-values" title="Permalink to this headline"></a></h3>
<p>The final value category of C++ (pr-values) is slightly more complex than l-values and x-values.
The <a class="reference external" href="http://eel.is/c++draft/expr.prop#basic.lval-1.2">C++ standard</a> describes them as follows:</p>
<p><a class="reference external" href="_static/coqdoc/bedrock.lang.cpp.logic.wp.html#WPE.wp_init">wp_init</a> handles the second of these two.
The parameter is the following:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>(* evaluate a prvalue that &quot;initializes an object&quot;.

   The continuation is passed two [FreeTemp.t]s, the first is to delete the
   value being initialized, the second is to delete temporaries created while
   creating the value. To delete both correctly, you must destroy the value
   *before* destroying the temporaries.
   Only destroying temporaries (and discarding the first argument) is legal
   when mandated by the semantics, for example, in a variable declaration.
   `int x = (C{}, 2);`

   The memory that is being initialized is already owned by the C++ abstract machine.
   Therefore, schematically, a [wp_init ty addr e Q] looks like the following:
     [[
        addr |-&gt; R ... 1 -* Q
     ]]
   This choice means that a thread needs to give up the memory to the abstract
   machine when it transitions to running a [wp_init]. In the case of
   stack allocation, there is nothing to do here, but in the case of [new],
   the memory must be given up.

   The C++ standard has many forms of initialization (see
   &lt;https://eel.is/c++draft/dcl.init&gt;). The Clang frontend (and therefore our
   AST) implements the different forms of initialization through elaboration.

   For example, in aggregate pass-by-value the standard states that copy initialization
   &lt;https://eel.is/c++draft/dcl.init#general-14&gt; is used; however, our AST
   produces an explicit [Econstructor] in the AST to represent this. This seems
   necessary to have a uniform representation of the various evoluations of
   initialization between different standards, e.g. C++14, C++17, etc.
 *)
Parameter wp_init
  : forall {resolve:genv}, region -&gt;
                      type -&gt; ptr -&gt; Expr -&gt;
                      (FreeTemp -&gt; FreeTemps -&gt; epred) -&gt; (* top-free -&gt; free -&gt; post *)
                      mpred. (* pre-condition *)
</pre></div>
</div>
<p>This definition has two interesting differences from <code class="code highlight coq docutils literal notranslate"><span class="n"><span class="pre">wp_lval</span></span></code> and <code class="code highlight coq docutils literal notranslate"><span class="n"><span class="pre">wp_xval</span></span></code>.
The first is that it takes a <a class="reference external" href="_static/coqdoc/bedrock.lang.cpp.semantics.values.html#PTRS.ptr">ptr</a> that represents the location that the object is being constructed into.
Because of this, the post-condition does not consume a value but instead a <code class="code highlight coq docutils literal notranslate"><span class="n"><span class="pre">FreeTemp</span></span></code> and a <code class="code highlight coq docutils literal notranslate"><span class="n"><span class="pre">FreeTemps</span></span></code>.
Both of these are simply <code class="code highlight coq docutils literal notranslate"><span class="n"><span class="pre">FreeTemps</span></span></code> under the hood but in this context they mean slightly different things.
The first argument is the <code class="code highlight coq docutils literal notranslate"><span class="n"><span class="pre">FreeTemp</span></span></code> that is used to destroy the object that is initialized by this expression.
The second is used to destroy the temporaries that are created while initializing the object.
For example, suppose you are calling a constructor <code class="code highlight coq docutils literal notranslate"><span class="n"><span class="pre">C</span></span><span class="o"><span class="pre">(</span></span><span class="mi"><span class="pre">1</span></span><span class="o"><span class="pre">+</span></span><span class="mi"><span class="pre">1</span></span><span class="o"><span class="pre">)</span></span></code>.
In this case, the constructed value (of type <code class="code highlight coq docutils literal notranslate"><span class="n"><span class="pre">C</span></span></code>) would be destroyed by <code class="code highlight coq docutils literal notranslate"><span class="n"><span class="pre">FreeTemp</span></span></code>, while the temporary that <code class="code highlight coq docutils literal notranslate"><span class="mi"><span class="pre">1</span></span><span class="o"><span class="pre">+</span></span><span class="mi"><span class="pre">1</span></span></code> evaluates to would be destroyed by <code class="code highlight coq docutils literal notranslate"><span class="n"><span class="pre">FreeTemps</span></span></code>.</p>
<p>On top of <code class="code highlight coq docutils literal notranslate"><span class="n"><span class="pre">wp_init</span></span></code>, we can <em>define</em> <code class="code highlight coq docutils literal notranslate"><span class="n"><span class="pre">wp_prval</span></span></code> by universally quantifying the pointer that is being initialized and passing it to the continuation.</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>Definition wp_prval {resolve:genv} (ρ : region)
           (e : Expr) (Q : ptr -&gt; FreeTemp -&gt; FreeTemps -&gt; epred) : mpred :=
  ∀ p : ptr, wp_init ρ (type_of e) p e (Q p).
</pre></div>
</div>
<p>Note that the pointer <code class="code highlight coq docutils literal notranslate"><span class="n"><span class="pre">p</span></span></code> is completely unconstrained in this definition.
In practice the C++ abstract machine will pick this pointer to be fresh and reserve it before proceeding to initialize it when evaluating <code class="code highlight coq docutils literal notranslate"><span class="n"><span class="pre">e</span></span></code>.</p>
<div class="section" id="operands">
<h4>Operands<a class="headerlink" href="#operands" title="Permalink to this headline"></a></h4>
<p><a class="reference external" href="_static/coqdoc/bedrock.lang.cpp.logic.wp.html#WPE.wp_operand">wp_operand</a> is used to evaluate a operand of a primitive operator.
These operands are <em>always</em> primitives, since operators that accept aggregates are desugared to functions or methods.</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>(* evaluate a prvalue that &quot;computes the value of an operand of an operator&quot;
 *)
Parameter wp_operand
  : forall {resolve:genv}, region -&gt;
      Expr -&gt;
      (val -&gt; FreeTemps -&gt; epred) -&gt; (* result -&gt; free -&gt; post *)
      mpred. (* pre-condition *)
</pre></div>
</div>
<p>Unlike <code class="code highlight coq docutils literal notranslate"><span class="n"><span class="pre">wp_init</span></span></code> and <code class="code highlight coq docutils literal notranslate"><span class="n"><span class="pre">wp_prval</span></span></code>, operands return <a class="reference external" href="_static/coqdoc/bedrock.lang.cpp.semantics.value.html#val">val</a>s.
Because the value returned does not have an identity, there is nothing to destroy, so, unlike <code class="code highlight coq docutils literal notranslate"><span class="n"><span class="pre">wp_prval</span></span></code> and <code class="code highlight coq docutils literal notranslate"><span class="n"><span class="pre">wp_init</span></span></code>, the continuation takes a single <code class="code highlight coq docutils literal notranslate"><span class="n"><span class="pre">FreeTemps</span></span></code>, which will destroy the temporaries created when evaluating the operand.</p>
<p>The relationship between <a class="reference external" href="_static/coqdoc/wp_operand.html">wp_operand</a> and <a class="reference external" href="_static/coqdoc/wp_init.html">wp_init</a> can be precisely characterized by the following two axioms.</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>Axiom wp_operand_wp_init : forall {σ : genv} ρ ty addr e Q,
    is_primitive ty -&gt;
    wp_operand ρ e (fun v frees =&gt; _at addr (primR ty 1 v) -* Q (FreeTemps.delete ty addr) frees)
  |-- wp_init ρ ty addr e Q.

(** This is justified in the logic but technically not sactioned by the standard

  [[
 Axiom wp_init_wp_operand : forall {σ : genv} M ρ addr e Q (ty := type_of e),
    is_primitive ty -&gt;
    wp_prval M ρ e (fun p free frees =&gt;
       [| FreeTemps.t_eq free (FreeTemps.delete ty addr) |] **
       ∃ v, _at addr (primR ty 1 v) ** Q v frees)
  |-- wp_operand M ρ e Q.
  ]]
 *)
</pre></div>
</div>
<p>The first of these axioms states that initializing <em>a primitive</em> using an expression <code class="code highlight coq docutils literal notranslate"><span class="n"><span class="pre">e</span></span></code> can be viewed as evaluating <code class="code highlight coq docutils literal notranslate"><span class="n"><span class="pre">e</span></span></code> using operand semantics and then materializing a value (using <a class="reference external" href="_static/coqdoc/bedrock.lang.cpp.logic.heap_pred.html#primR">primR</a>) with the value and the type of the expression.
The second of these axioms, which is not technically justified by the standard and is therefore only provided for documentation purposes, states that evaluating an operand can be viewed as initializing a fresh primitive object, reading the value out of it, destroying it, and then returning the result to the continuation <code class="code highlight coq docutils literal notranslate"><span class="n"><span class="pre">Q</span></span></code>.
The reason that this rule is not technically justified by the standard is because the C++ standard states explicitly that there is no identity associated with this sort of value.
However, since the existence of a pointer does not imply that the object has a location in the BRiCk model, we can create a fresh <code class="code highlight coq docutils literal notranslate"><span class="n"><span class="pre">ptr</span></span></code> and then immediately destroy it.</p>
</div>
</div>
<div class="section" id="function-call-semantics">
<h3>Function Call Semantics<a class="headerlink" href="#function-call-semantics" title="Permalink to this headline"></a></h3>
<p>The semantics for function calls is concerned with the way that we pass arguments to functions and (potentially) recieve the return value.
We note that it is important to handle the passing of primitives as well as aggregates, both of which are very common in C++.
The semantics for function calls specifies how to pass arguments to functions and (potentially) get back the return value, both for primitives and for aggregates.</p>
<p>BRiCk follows the C++ standard by <a class="reference external" href="https://eel.is/c++draft/expr.call#7">using initialization semantics to pass (and return) data to (and from) functions</a>.
It is also the style taken by <a class="reference external" href="https://www.cl.cam.ac.uk/~pes20/cerberus/">Cerberus</a>.</p>
<p class="rubric">Footnotes</p>
<dl class="footnote brackets">
<dt class="label" id="parallel-destruction"><span class="brackets"><a class="fn-backref" href="#id2">1</a></span></dt>
<dd><p>We use <code class="code highlight coq docutils literal notranslate"><span class="n"><span class="pre">par</span></span></code> to under approximate the destruction order of temporaries when C++ does not guarantee it statically. For example, in the function call <code class="code highlight coq docutils literal notranslate"><span class="n"><span class="pre">f</span></span><span class="o"><span class="pre">(</span></span><span class="n"><span class="pre">a</span></span><span class="o"><span class="pre">,</span></span><span class="n"><span class="pre">b</span></span><span class="o"><span class="pre">,</span></span><span class="n"><span class="pre">c</span></span><span class="o"><span class="pre">)</span></span></code>, the expressions <code class="code highlight coq docutils literal notranslate"><span class="n"><span class="pre">a</span></span></code>, <code class="code highlight coq docutils literal notranslate"><span class="n"><span class="pre">b</span></span></code>, and <code class="code highlight coq docutils literal notranslate"><span class="n"><span class="pre">c</span></span></code> can be evaluated in any order and we can approximate the ordering provided by c++ by saying they are destroyed in parallel.</p>
</dd>
<dt class="label" id="non-observable-destructors"><span class="brackets">2</span></dt>
<dd><p>Part of the justification for this is that the arguments to functions do not have names in the callees stack frame, so the locations of those objects are not accessible to other objects (something that could influence the semantics due to live pointers).</p>
</dd>
</dl>
</div>
</div>
</div>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="features.html" class="btn btn-neutral float-left" title="Language Support" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="undefined_behavior.html" class="btn btn-neutral float-right" title="Undefined behavior and optimizations" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2021 BedRock Systems.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>