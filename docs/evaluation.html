<!DOCTYPE html>
<html class="writer-html5" lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Evaluation &mdash; BedRock BRiCk alpha documentation</title>
      <link rel="stylesheet" type="text/css" href="_static/pygments.css" />
      <link rel="stylesheet" type="text/css" href="_static/css/theme.css" />
      <link rel="stylesheet" type="text/css" href="_static/alectryon.css" />
      <link rel="stylesheet" type="text/css" href="_static/css/justify.css" />

  
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
        <script src="_static/jquery.js"></script>
        <script src="_static/underscore.js"></script>
        <script src="_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script src="_static/doctools.js"></script>
        <script src="_static/alectryon.js"></script>
    <script src="_static/js/theme.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Undefined behavior and optimizations" href="undefined_behavior.html" />
    <link rel="prev" title="Language Support" href="features.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="index.html" class="icon icon-home">
            BedRock BRiCk
          </a>
              <div class="version">
                0.5.0
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Table of Contents</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="features.html">Language Support</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Evaluation</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#expressions">Expressions</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#modeling-temporaries">Modeling Temporaries</a></li>
<li class="toctree-l3"><a class="reference internal" href="#l-values-x-values">l-values &amp; x-values</a></li>
<li class="toctree-l3"><a class="reference internal" href="#pr-values">pr-values</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#operands">Operands</a></li>
<li class="toctree-l4"><a class="reference internal" href="#initializing-aggregates">Initializing Aggregates</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#initialization">Initialization</a></li>
<li class="toctree-l3"><a class="reference internal" href="#function-call-semantics">Function Call Semantics</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="undefined_behavior.html">Undefined behavior and optimizations</a></li>
<li class="toctree-l1"><a class="reference internal" href="pointers.html">Pointers and pointer provenance</a></li>
<li class="toctree-l1"><a class="reference internal" href="object_layout.html">Object representation, layout and padding</a></li>
<li class="toctree-l1"><a class="reference internal" href="machine.html">Assembly Interoperation</a></li>
<li class="toctree-l1"><a class="reference internal" href="documentation.html">Code Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="proof_examples.html">Proof Examples</a></li>
<li class="toctree-l1"><a class="reference internal" href="bibliography.html">Related work and bibliography</a></li>
<li class="toctree-l1"><a class="reference internal" href="acknowledgements.html">Acknowledgements</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">BedRock BRiCk</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content style-external-links">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="index.html" class="icon icon-home" aria-label="Home"></a></li>
      <li class="breadcrumb-item active">Evaluation</li>
      <li class="wy-breadcrumbs-aside">
            <a href="_sources/evaluation.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <div class="section" id="evaluation">
<span id="id1"></span><h1>Evaluation<a class="headerlink" href="#evaluation" title="Permalink to this heading"></a></h1>
<p>The semantics of C++ programs in BRiCk are written in <a class="reference external" href="https://en.wikipedia.org/wiki/Predicate_transformer_semantics">weakest (liberal) pre-condition style</a>.
The general form of these rules is the following:</p>
<p>Note that <code class="code highlight coq docutils literal notranslate"><span class="n"><span class="pre">wp</span></span></code> is a predicate in our separation logic (the fact that it returns a <code class="code highlight coq docutils literal notranslate"><span class="n"><span class="pre">PROP</span></span></code>).
Informally you can think of it as capturing the pre-condition to the inputs (one of which is normally an expression) that are sufficient such that the code is safe and if the expression terminates, it terminates in a state in which its outputs statisfy the “continuation” (i.e. the final function argument to <code class="code highlight coq docutils literal notranslate"><span class="n"><span class="pre">wp</span></span></code>).</p>
<p>Due to the structure of C++, BRiCk contains a separate weakest pre-condition modality for each syntactic category. These are defined in <a class="reference external" href="_static/coqdoc/bedrock.lang.cpp.logic.wp.html">bedrock.lang.cpp.logic.wp</a>.</p>
<div class="section" id="expressions">
<h2>Expressions<a class="headerlink" href="#expressions" title="Permalink to this heading"></a></h2>
<p>In BRiCk we break expression evaluation down into four weakest pre-condition assertions representing the different <a class="reference external" href="http://eel.is/c++draft/expr.prop#basic.lval-1">value categories</a> of a C++ expression.</p>
<div class="section" id="modeling-temporaries">
<h3>Modeling Temporaries<a class="headerlink" href="#modeling-temporaries" title="Permalink to this heading"></a></h3>
<p>In the course of evaluating C++ programs, the language can construct objects that are later destroyed, this occurs for <a class="reference external" href="https://eel.is/c++draft/basic.stc.auto#1">automatic storage duration</a> variables (i.e. stack allocated variables and temporaries).
C++ semantics guarantees that the lifetime of temporaries is well-bracketed, meaning that objects will be destroyed in the reverse order that they were constructed.
In BRiCk we capture the stack of objects to be destroyed using the type <a class="reference external" href="_static/coqdoc/bedrock.lang.cpp.logic.wp.html#FreeTemps.t">t</a>.</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>Inductive t : Set :=
| id (* = fun x =&gt; x *)
| delete (ty : decltype) (p : ptr) (* = delete_val ty p *)
| delete_va (va : list (type * ptr)) (p : ptr)
| seq (f g : t) (* = fun x =&gt; f $ g x *)
| par (f g : t) (* = fun x =&gt; Exists Qf Qg, f Qf ** g Qg ** (Qf -* Qg -* x) *)
.
</pre></div>
</div>
<p>Here <a class="reference external" href="_static/coqdoc/bedrock.lang.cpp.logic.wp.html#FreeTemps.id">id</a> represents the identity, characterizing that nothing needs to be destroyed.
<code class="code highlight coq docutils literal notranslate"><span class="n"><span class="pre">delete</span></span> <span class="n"><span class="pre">ty</span></span> <span class="n"><span class="pre">p</span></span></code> represents that the value at pointer <code class="code highlight coq docutils literal notranslate"><span class="n"><span class="pre">p</span></span></code> (which should have type <code class="code highlight coq docutils literal notranslate"><span class="n"><span class="pre">ty</span></span></code>) needs to be destroyed.
Note that to delete the value, the C++ abstract machine runs the destructor and reclaims the underlying memory.
Virtual dispatch is <em>not</em> used when invoking the destructor.
<code class="code highlight coq docutils literal notranslate"><span class="n"><span class="pre">seq</span></span> <span class="n"><span class="pre">a</span></span> <span class="n"><span class="pre">b</span></span></code> means that the temporaries in <code class="code highlight coq docutils literal notranslate"><span class="n"><span class="pre">a</span></span></code> must be destroyed <em>before</em> the temporaries in <code class="code highlight coq docutils literal notranslate"><span class="n"><span class="pre">b</span></span></code>.
<code class="code highlight coq docutils literal notranslate"><span class="n"><span class="pre">par</span></span> <span class="n"><span class="pre">a</span></span> <span class="n"><span class="pre">b</span></span></code> means that the temporaries in <code class="code highlight coq docutils literal notranslate"><span class="n"><span class="pre">a</span></span></code> and the temporaries in <code class="code highlight coq docutils literal notranslate"><span class="n"><span class="pre">b</span></span></code> are destroyed in an interleaved manner <a class="footnote-reference brackets" href="#parallel-destruction" id="id2">1</a>.</p>
<p>The meaning of these constructs is made precise by interpreting the syntax using <a class="reference external" href="_static/coqdoc/bedrock.lang.cpp.logic.destroy.html#interp">interp</a>.</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>#[local] Definition interp_body `{Σ : cpp_logic, σ : genv}
    (interp : translation_unit -&gt; FreeTemps -&gt; epred -&gt; mpred)
    (tu : translation_unit) (free : FreeTemps) (Q : epred) : mpred :=
  match free with
  | FreeTemps.id =&gt; |={top}=&gt; Q
  | FreeTemps.seq f g =&gt; interp tu f $ interp tu g Q
  | FreeTemps.par f g =&gt; |={top}=&gt; Exists Qf Qg, interp tu f Qf ** interp tu g Qg ** (Qf -* Qg -* |={top}=&gt; Q)
  | FreeTemps.delete ty addr =&gt; destroy_val tu ty addr Q
  | FreeTemps.delete_va va addr =&gt; |={top}=&gt; addr |-&gt; varargsR va ** Q
  end.

mlock Definition interp `{Σ : cpp_logic, σ : genv}
    : translation_unit -&gt; FreeTemps -&gt; epred -&gt; mpred :=
  fix interp tu free :=
  interp_body interp tu free.
#[global] Arguments interp {_ _ _ _} _ free Q : assert.	(* set names *)
</pre></div>
</div>
</div>
<div class="section" id="l-values-x-values">
<h3>l-values &amp; x-values<a class="headerlink" href="#l-values-x-values" title="Permalink to this heading"></a></h3>
<p>l-values and x-values follow the same general structure.
Their weakest precondition rules are captured by <a class="reference external" href="_static/coqdoc/bedrock.lang.cpp.logic.wp.html#WPE.wp_lval">wp_lval</a> and <a class="reference external" href="_static/coqdoc/bedrock.lang.cpp.logic.wp.html#WPE.wp_xval">wp_xval</a> respectively (we show <code class="code highlight coq docutils literal notranslate"><span class="n"><span class="pre">wp_lval</span></span></code> as our example).</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>(* [wp_lval σ E ρ e Q] evaluates the expression [e] in region [ρ]
 * with mask [E] and continutation [Q].
 *)
Parameter wp_lval
  : forall {resolve:genv}, translation_unit -&gt; region -&gt; Expr -&gt; M ptr.
</pre></div>
</div>
</div>
<div class="section" id="pr-values">
<h3>pr-values<a class="headerlink" href="#pr-values" title="Permalink to this heading"></a></h3>
<p>The final value category of C++ (pr-values) is slightly more complex than l-values and x-values.
The <a class="reference external" href="http://eel.is/c++draft/expr.prop#basic.lval-1.2">C++ standard</a> describes them as follows:</p>
<p>These are characterized by two predicate transformers.</p>
<div class="section" id="operands">
<h4>Operands<a class="headerlink" href="#operands" title="Permalink to this heading"></a></h4>
<p><a class="reference external" href="_static/coqdoc/bedrock.lang.cpp.logic.wp.html#WPE.wp_operand">wp_operand</a> is used to evaluate a operand of a primitive operator.
These operands are <em>always</em> primitives, since operators that accept aggregates are desugared to functions or methods.</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>(* evaluate a prvalue that &quot;computes the value of an operand of an operator&quot;
 *)
Parameter wp_operand : forall {resolve:genv}, translation_unit -&gt; region -&gt; Expr -&gt; M val.
</pre></div>
</div>
<p>Unlike <code class="code highlight coq docutils literal notranslate"><span class="n"><span class="pre">wp_init</span></span></code> and <code class="code highlight coq docutils literal notranslate"><span class="n"><span class="pre">wp_prval</span></span></code>, operands return <a class="reference external" href="_static/coqdoc/bedrock.lang.cpp.semantics.value.html#val">val</a>s.
Because the value returned does not have an identity, there is nothing to destroy, so the <code class="code highlight coq docutils literal notranslate"><span class="n"><span class="pre">FreeTemps</span></span></code> returned to the continuation destroys only the temporaries created when evaluating the expression.</p>
</div>
<div class="section" id="initializing-aggregates">
<h4>Initializing Aggregates<a class="headerlink" href="#initializing-aggregates" title="Permalink to this heading"></a></h4>
<p><a class="reference external" href="_static/coqdoc/bedrock.lang.cpp.logic.wp.html#WPE.wp_init">wp_init</a> handles initialization of aggregates.
The parameter is the following:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>(* evaluate a prvalue that &quot;initializes an object&quot;.

   [wp_init tu ρ ty p e Q] evaluates [e] to initialize a value of type [ty]
   at location [p] in the region [ρ]. The continuation [Q] is passed the
   [FreeTemps.t] needed to destroy temporaries created while evaluating [e],
   but does *not* include the destruction of [p].
   The type [ty] and the type of the expression, i.e. [type_of e], are related
   but not always the same. We call [ty] the *dynamic type* and [type_of e]
   the *static type*. The two types should always be compatible, but the dynamic
   type might have more information. For example, in the expression:
   [[
   int n = 7;
   auto p = new C[n]{};
   ]]
   When running the initializer to initialize the memory returned by [new],
   the dynamic type will be [Tarray &quot;C&quot; 7], while the static type will be
   [Tarray &quot;C&quot; 0] (the [0] is an artifact of clang).

   The memory that is being initialized is already owned by the C++ abstract
   machine. Therefore, schematically, a [wp_init ty addr e Q] looks like the
   following: [[ addr |-&gt; R ... 1 -* Q ]] This choice means that a thread
   needs to give up the memory to the abstract machine when it transitions to
   running a [wp_init]. In the case of stack allocation, there is nothing to
   do here, but in the case of [new], the memory must be given up.

   The C++ standard has many forms of initialization (see
   &lt;https://eel.is/c++draft/dcl.init&gt;). The Clang frontend (and therefore our
   AST) implements the different forms of initialization through elaboration.

   For example, in aggregate pass-by-value the standard states that copy
   initialization &lt;https://eel.is/c++draft/dcl.init#general-14&gt; is used;
   however, the BRiCk AST contains an explicit [Econstructor] in the AST to
   represent this. This seems necessary to have a uniform representation of
   the various evoluations of initialization between different standards, e.g.
   C++14, C++17, etc.

   NOTE: this is morally [M unit], but we inline the definition of [M] and
   ellide the [unit] value. *)
Parameter wp_init
  : forall {resolve:genv}, translation_unit -&gt; region -&gt;
                      exprtype -&gt; ptr -&gt; Expr -&gt;
                      (FreeTemps -&gt; epred) -&gt; (* free -&gt; post *)
                      mpred. (* pre-condition *)
</pre></div>
</div>
<p><code class="code highlight coq docutils literal notranslate"><span class="n"><span class="pre">wp_init</span></span></code> takes a <a class="reference external" href="_static/coqdoc/bedrock.lang.cpp.semantics.values.html#PTRS.ptr">ptr</a> that represents the location that the object is being constructed into.
Because of this, the post-condition does not consume a value but only a <code class="code highlight coq docutils literal notranslate"><span class="n"><span class="pre">FreeTemps</span></span></code> used to destroy temporaries created during the evaluation of the expression.
To destroy the actual object constructed by <code class="code highlight coq docutils literal notranslate"><span class="n"><span class="pre">wp_init</span></span> <span class="n"><span class="pre">ty</span></span> <span class="n"><span class="pre">into</span></span> <span class="n"><span class="pre">Q</span></span></code>, use <code class="code highlight coq docutils literal notranslate"><span class="n"><span class="pre">FreeTemps</span></span><span class="o"><span class="pre">.</span></span><span class="n"><span class="pre">delete</span></span> <span class="n"><span class="pre">ty</span></span> <span class="n"><span class="pre">into</span></span></code>.</p>
<p>On top of <code class="code highlight coq docutils literal notranslate"><span class="n"><span class="pre">wp_init</span></span></code>, we can <em>define</em> <code class="code highlight coq docutils literal notranslate"><span class="n"><span class="pre">wp_prval</span></span></code> by universally quantifying the pointer that is being initialized and passing it to the continuation.</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>Definition wp_prval {resolve:genv} (tu : translation_unit) (ρ : region)
           (e : Expr) (Q : ptr -&gt; FreeTemps -&gt; epred) : mpred :=
  ∀ p : ptr, wp_init tu ρ (type_of e) p e (Q p).
</pre></div>
</div>
<p>Note that the pointer <code class="code highlight coq docutils literal notranslate"><span class="n"><span class="pre">p</span></span></code> is completely unconstrained in this definition.
In practice the C++ abstract machine will pick this pointer to be fresh and reserve it before proceeding to initialize during the evaluation of <code class="code highlight coq docutils literal notranslate"><span class="n"><span class="pre">e</span></span></code>.</p>
</div>
</div>
<div class="section" id="initialization">
<h3>Initialization<a class="headerlink" href="#initialization" title="Permalink to this heading"></a></h3>
<p>Initialization is slightly more complex than <code class="code highlight coq docutils literal notranslate"><span class="n"><span class="pre">wp_init</span></span></code> because you can initialize aggregates (using <code class="code highlight coq docutils literal notranslate"><span class="n"><span class="pre">wp_init</span></span></code>), primitives (using <code class="code highlight coq docutils literal notranslate"><span class="n"><span class="pre">wp_operand</span></span></code>), and references (using <code class="code highlight coq docutils literal notranslate"><span class="n"><span class="pre">wp_lval</span></span></code> and <code class="code highlight coq docutils literal notranslate"><span class="n"><span class="pre">wp_xval</span></span></code>).
To capture this, BRiCk <em>defines</em> <code class="code highlight coq docutils literal notranslate"><span class="n"><span class="pre">wp_initialize</span></span></code> which provides the semantics to materialize a value into the C++ abstract machine state (which BRiCk reflects through separation logic assertions such as <code class="code highlight coq docutils literal notranslate"><span class="n"><span class="pre">primR</span></span></code>).
<code class="code highlight coq docutils literal notranslate"><span class="n"><span class="pre">wp_initialize</span></span></code> is defined by induction on the type of the value being initialized with special handling of <code class="code highlight coq docutils literal notranslate"><span class="n"><span class="pre">const</span></span></code> qualifiers.</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>#[local] Definition wp_initialize_unqualified_body `{Σ : cpp_logic, σ : genv}
    (u : bool) (tu : translation_unit) (ρ : region)
    (cv : type_qualifiers) (ty : decltype)
    (addr : ptr) (init : Expr) (Q : FreeTemps -&gt; epred) : mpred :=
  let UNSUPPORTED := funI m =&gt; |={top}=&gt;?u UNSUPPORTED m in
  if q_volatile cv then False%I
  else
    match ty with
    | Tvoid =&gt;
      (*
      [wp_initialize] is used to `return` from a function. The following
      is legal in C++:
      &lt;&lt;
        void f();
        void g() { return f(); }
      &gt;&gt;
      *)
      letI* v, frees := wp_operand tu ρ init in
      let qf := cQp.mk (q_const cv) 1 in
      [| v = Vvoid |] **

      (**
      [primR] is enough because C++ code never uses the raw bytes
      underlying an inhabitant of type void.
      *)
      (addr |-&gt; primR Tvoid qf Vvoid -* |={top}=&gt;?u Q frees)

    | Tpointer _
    | Tmember_pointer _ _
    | Tbool
    | Tnum _ _
    | Tchar_ _
    | Tenum _
    | Tfloat_ _
    | Tnullptr =&gt;
      letI* v, free := wp_operand tu ρ init in
      let qf := cQp.mk (q_const cv) 1 in
      addr |-&gt; tptsto_fuzzyR (erase_qualifiers ty) qf v -* |={top}=&gt;?u Q free

      (* non-primitives are handled via prvalue-initialization semantics *)
    | Tarray _ _
    | Tnamed _ =&gt; wp_init tu ρ (tqualified cv ty) addr init Q
    | Tincomplete_array _ =&gt; UNSUPPORTED (initializing_type ty init)
    | Tvariable_array _ =&gt; UNSUPPORTED (initializing_type ty init)

    | Tref ty =&gt;
      let rty := Tref $ erase_qualifiers ty in
      letI* p, free := wp_lval tu ρ init in
      let qf := cQp.mk (q_const cv) 1 in
      (*
      [primR] is enough because C++ code never uses the raw bytes
      underlying an inhabitant of a reference type.

      TODO: [ref]s are never mutable, but we use [qf] here for
      compatibility with [implicit_destruct_struct]
      *)
      addr |-&gt; primR rty qf (Vref p) -* |={top}=&gt;?u Q free

    | Trv_ref ty =&gt;
      let rty := Tref $ erase_qualifiers ty in
      letI* p, free := wp_xval tu ρ init in
      let qf := cQp.mk (q_const cv) 1 in
      (*
      [primR] is enough because C++ code never uses the raw bytes
      underlying an inhabitant of a reference type.

      TODO: [ref]s are never mutable, but we use [qf] here for
      compatibility with [implicit_destruct_struct]
      *)
      addr |-&gt; primR rty qf (Vref p) -* |={top}=&gt;?u Q free

    | Tfunction _ _ =&gt; UNSUPPORTED (initializing_type ty init)

    | Tqualified _ ty =&gt; |={top}=&gt;?u False (* unreachable *)
    | Tarch _ _ =&gt; UNSUPPORTED (initializing_type ty init)
    end%I.

mlock
Definition wp_initialize_unqualified `{Σ : cpp_logic, σ : genv} :
  ∀ (tu : translation_unit) (ρ : region)
    (cv : type_qualifiers) (ty : decltype)
    (addr : ptr) (init : Expr) (Q : FreeTemps -&gt; epred), mpred :=
  Cbn (Reduce (wp_initialize_unqualified_body fupd_compatible)).
#[global] Arguments wp_initialize_unqualified {_ _ _ _} _ _ _ _ _ _ _%I : assert.	(* mlock bug *)

Definition wp_initialize `{Σ : cpp_logic, σ : genv} (tu : translation_unit) (ρ : region)
    (qty : decltype) (addr : ptr) (init : Expr) (Q : FreeTemps -&gt; epred) : mpred :=
  qual_norm (wp_initialize_unqualified tu ρ) qty addr init Q.
#[global] Hint Opaque wp_initialize : typeclass_instances.
#[global] Arguments wp_initialize {_ _ _ _} _ _ !_ _ _ _ / : assert.
</pre></div>
</div>
</div>
<div class="section" id="function-call-semantics">
<h3>Function Call Semantics<a class="headerlink" href="#function-call-semantics" title="Permalink to this heading"></a></h3>
<p>The semantics for function calls is concerned with the way that we pass arguments to functions and (potentially) recieve the return value.
We note that it is important to handle the passing of primitives as well as aggregates, both of which are very common in C++.
The semantics for function calls specifies how to pass arguments to functions and (potentially) get back the return value, both for primitives and for aggregates.</p>
<p>BRiCk follows the C++ standard by <a class="reference external" href="https://eel.is/c++draft/expr.call#7">using initialization semantics to pass (and return) data to (and from) functions</a>.
It is also the style taken by <a class="reference external" href="https://www.cl.cam.ac.uk/~pes20/cerberus/">Cerberus</a>.</p>
<p class="rubric">Footnotes</p>
<dl class="footnote brackets">
<dt class="label" id="parallel-destruction"><span class="brackets"><a class="fn-backref" href="#id2">1</a></span></dt>
<dd><p>We use <code class="code highlight coq docutils literal notranslate"><span class="n"><span class="pre">par</span></span></code> to under approximate the destruction order of temporaries when C++ does not guarantee it statically. For example, in the function call <code class="code highlight coq docutils literal notranslate"><span class="n"><span class="pre">f</span></span><span class="o"><span class="pre">(</span></span><span class="n"><span class="pre">a</span></span><span class="o"><span class="pre">,</span></span><span class="n"><span class="pre">b</span></span><span class="o"><span class="pre">,</span></span><span class="n"><span class="pre">c</span></span><span class="o"><span class="pre">)</span></span></code>, the expressions <code class="code highlight coq docutils literal notranslate"><span class="n"><span class="pre">a</span></span></code>, <code class="code highlight coq docutils literal notranslate"><span class="n"><span class="pre">b</span></span></code>, and <code class="code highlight coq docutils literal notranslate"><span class="n"><span class="pre">c</span></span></code> can be evaluated in any order and we can approximate the ordering provided by c++ by saying they are destroyed in parallel.</p>
</dd>
<dt class="label" id="non-observable-destructors"><span class="brackets">2</span></dt>
<dd><p>Part of the justification for this is that the arguments to functions do not have names in the callees stack frame, so the locations of those objects are not accessible to other objects (something that could influence the semantics due to live pointers).</p>
</dd>
</dl>
</div>
</div>
</div>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="features.html" class="btn btn-neutral float-left" title="Language Support" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="undefined_behavior.html" class="btn btn-neutral float-right" title="Undefined behavior and optimizations" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2021 BedRock Systems.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>