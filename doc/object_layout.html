

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  
  <title>Object representation, layout and padding &mdash; BedRock BRiCk alpha documentation</title>
  

  
  <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="_static/alectryon.css" type="text/css" />
  <link rel="stylesheet" href="_static/tango_subtle.min.css" type="text/css" />
  <link rel="stylesheet" href="_static/css/justify.css" type="text/css" />

  
  

  
  

  

  
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
        <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
        <script src="_static/jquery.js"></script>
        <script src="_static/underscore.js"></script>
        <script src="_static/doctools.js"></script>
        <script src="_static/alectryon.js"></script>
    
    <script type="text/javascript" src="_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Assembly Interoperation" href="machine.html" />
    <link rel="prev" title="Pointers and pointer provenance" href="pointers.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="index.html" class="icon icon-home"> BedRock BRiCk
          

          
          </a>

          
            
            
              <div class="version">
                0.5.0
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption" role="heading"><span class="caption-text">Table of Contents</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="features.html">Language Support</a></li>
<li class="toctree-l1"><a class="reference internal" href="undefined_behavior.html">Undefined behavior and optimizations</a></li>
<li class="toctree-l1"><a class="reference internal" href="pointers.html">Pointers and pointer provenance</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Object representation, layout and padding</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#reasoning-about-the-layout-of-a-struct-in-memory">Reasoning about the layout of a struct in memory</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#how-is-this-reflected-in-project">How is this reflected in BRiCk?</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#reasoning-about-the-layout-of-an-array-in-memory">Reasoning about the layout of an array in memory</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id4">How is this reflected in BRiCk?</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#reasoning-about-the-layout-of-a-union-in-memory">Reasoning about the layout of a union in memory</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#how-is-this-reflected-in-cpp2v">How is this reflected in cpp2v?</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#working-with-the-low-level-representation-of-objects">Working with the low-level representation of objects</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id5">How is this reflected in BRiCk?</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#representing-values">Representing Values</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#pinned-pointers">Pinned Pointers</a></li>
<li class="toctree-l3"><a class="reference internal" href="#function-call-semantics">Function Call Semantics</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="machine.html">Assembly Interoperation</a></li>
<li class="toctree-l1"><a class="reference internal" href="documentation.html">Code Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="bibliography.html">Related work and bibliography</a></li>
<li class="toctree-l1"><a class="reference internal" href="acknowledgements.html">Acknowledgements</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">BedRock BRiCk</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content style-external-links">
        
          

















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html" class="icon icon-home"></a> &raquo;</li>
        
      <li>Object representation, layout and padding</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
          
            <a href="_sources/object_layout.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="object-representation-layout-and-padding">
<h1>Object representation, layout and padding<a class="headerlink" href="#object-representation-layout-and-padding" title="Permalink to this headline">¶</a></h1>
<p>This document highlights some tricky aspects around object
representation, layout and padding in C++ and describes how BRiCk deals with them.</p>
<p>A basic problem when formalizing C(++) is that there are multiple ways to view the same data <a class="footnote-reference brackets" href="#krebbers-thesis-2-5" id="id2">1</a>:</p>
<ul class="simple">
<li><p>In a <em>high-level</em> way using arrays, structs and unions.</p></li>
<li><p>In a <em>low-level</em> way using unstructured and untyped byte representations.</p></li>
</ul>
<p>This especially affects reasoning about the representation of an object in memory, i.e. how it is laid out and how data that is part of the low-level presentation, but not part of the high-level representation is handled (i.e. padding).</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Much of the reasoning described in this section is still experimental and subject to change.
In practice, most C++ programs do not require this level of reasoning.</p>
</div>
<div class="section" id="reasoning-about-the-layout-of-a-struct-in-memory">
<h2>Reasoning about the layout of a struct in memory<a class="headerlink" href="#reasoning-about-the-layout-of-a-struct-in-memory" title="Permalink to this headline">¶</a></h2>
<p>Reasoning about the layout of an object in memory is often required when interacting with drivers.
For example, consider the following code:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="o">*</span><span class="n">dma_address</span> <span class="o">=</span> <span class="p">...;</span>
<span class="k">struct</span> <span class="n">dma_struct</span> <span class="p">{</span>
  <span class="n">uint64</span> <span class="n">a</span><span class="p">;</span>
  <span class="n">uint64</span> <span class="n">b</span><span class="p">;</span>
<span class="p">};</span>

<span class="kt">void</span> <span class="nf">do_dma</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">struct</span> <span class="n">dma_struct</span> <span class="o">*</span><span class="n">ptr</span> <span class="o">=</span> <span class="n">dma_address</span><span class="p">;</span>
  <span class="c1">// This examples ignores concerns about UB via data-races or the compiler reordering writes or endianness concerns or alignment</span>
  <span class="n">ptr</span><span class="o">-&gt;</span><span class="n">a</span> <span class="o">=</span> <span class="p">...;</span> <span class="c1">// (1) This write must go to dma_address + 0</span>
  <span class="n">ptr</span><span class="o">-&gt;</span><span class="n">b</span> <span class="o">=</span> <span class="p">...;</span> <span class="c1">// (2) This write must go to dma_address + 8</span>
<span class="p">}</span>
</pre></div>
</div>
<p>This code communicates with a device via DMA by casting a pointer to a <code class="code highlight coq docutils literal notranslate"><span class="k"><span class="pre">struct</span></span></code> and then uses field accesses to write to memory.
The important point is that the writes on line <code class="code highlight coq docutils literal notranslate"><span class="o"><span class="pre">(</span></span><span class="mi"><span class="pre">1</span></span><span class="o"><span class="pre">)</span></span></code> and <code class="code highlight coq docutils literal notranslate"><span class="o"><span class="pre">(</span></span><span class="mi"><span class="pre">2</span></span><span class="o"><span class="pre">)</span></span></code>, must go to the address <code class="code highlight coq docutils literal notranslate"><span class="n"><span class="pre">dma_address</span></span> <span class="o"><span class="pre">+</span></span> <span class="mi"><span class="pre">0</span></span></code> resp. <code class="code highlight coq docutils literal notranslate"><span class="n"><span class="pre">dma_address</span></span> <span class="o"><span class="pre">+</span></span> <span class="mi"><span class="pre">8</span></span></code> for correctness.
In particular, there must not be padding at the start of the <code class="code highlight coq docutils literal notranslate"><span class="k"><span class="pre">struct</span></span></code> and between <code class="code highlight coq docutils literal notranslate"><span class="n"><span class="pre">a</span></span></code> and <code class="code highlight coq docutils literal notranslate"><span class="n"><span class="pre">b</span></span></code>.</p>
<p>How can this reasoning be justified?
The C++ standard itself only gives light guarantees about <a class="reference external" href="http://eel.is/c++draft/class.mem#26">layout of structs</a>:</p>
<blockquote class="pull-quote">
<div><p>If a standard-layout class object has any non-static data members, its address is the same as the address of its first non-static data member if that member is not a bit-field.
Its address is also the same as the address of each of its base class subobjects.
[Note: There might therefore be unnamed padding within a standard-layout struct object inserted by an implementation, but not at its beginning, as necessary to achieve appropriate alignment.
— end note]</p>
</div></blockquote>
<p>Thus, the C++ standard guarantees that the write on line <code class="code highlight coq docutils literal notranslate"><span class="o"><span class="pre">(</span></span><span class="mi"><span class="pre">1</span></span><span class="o"><span class="pre">)</span></span></code> goes to  <code class="code highlight coq docutils literal notranslate"><span class="n"><span class="pre">dma_address</span></span> <span class="o"><span class="pre">+</span></span> <span class="mi"><span class="pre">0</span></span></code>, but on its own it does not guarantee that there won’t be padding between <code class="code highlight coq docutils literal notranslate"><span class="n"><span class="pre">a</span></span></code> and <code class="code highlight coq docutils literal notranslate"><span class="n"><span class="pre">b</span></span></code>.
More concrete guarantees are given by the platform ABI. For example, the ARM ABI <a class="footnote-reference brackets" href="#abi-arm" id="id3">2</a> guarantees that</p>
<blockquote class="pull-quote">
<div><ul class="simple">
<li><p>The alignment of an aggregate shall be the alignment of its most-aligned component.</p></li>
<li><p>The size of an aggregate shall be the smallest multiple of its alignment that is sufficient to hold all of its members when they are laid out according to these rules.</p></li>
</ul>
</div></blockquote>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Additional assumption: For standard-layout class objects, compilers only insert padding between fields if it is necessary to achieve alignment.</p>
</div>
<div class="section" id="how-is-this-reflected-in-project">
<h3>How is this reflected in BRiCk?<a class="headerlink" href="#how-is-this-reflected-in-project" title="Permalink to this headline">¶</a></h3>
<p>The virtual address offset of a <a class="reference external" href="_static/coqdoc/bedrock.lang.cpp.semantics.ptrs.html#offset">offset</a> is determined by <a class="reference external" href="_static/coqdoc/bedrock.lang.cpp.semantics.ptrs.html#eval_offset">eval_offset</a>.
BRiCk currently supports reasoning about the layout of (a limited number of) aggregates by embedding the layout information from the Clang front-end into the BRiCk abstract syntax tree (see <a class="reference external" href="_static/coqdoc/bedrock.lang.cpp.syntax.translation_unit.html#Struct">Struct</a> and <a class="reference external" href="_static/coqdoc/bedrock.lang.cpp.syntax.translation_unit.html#Union">Union</a>).
Because the C++ standard only requires portability of the layout of certain types of aggregates we limit the use of this information in our axioms to POD and standard layout classes (see <a class="reference external" href="_static/coqdoc/bedrock.lang.cpp.semantics.ptrs.html#eval_o_field">eval_o_field</a>.</p>
<p>We believe that a good, platform independent way to reason about layout information is to use a combination of <code class="code highlight cpp docutils literal notranslate"><span class="k"><span class="pre">static_assert</span></span></code> and <code class="code highlight cpp docutils literal notranslate"><span class="n"><span class="pre">offsetof</span></span></code>.
BRiCk does not currently support this level of reasoning about <code class="code highlight cpp docutils literal notranslate"><span class="n"><span class="pre">offsetof</span></span></code>, but it is likely to be added in the future by connecting <a class="reference external" href="_static/coqdoc/bedrock.lang.cpp.semantics.ptrs.html#eval_offset">eval_offset</a> to the semantics of <code class="code highlight cpp docutils literal notranslate"><span class="n"><span class="pre">offsetof</span></span></code>.</p>
</div>
</div>
<div class="section" id="reasoning-about-the-layout-of-an-array-in-memory">
<h2>Reasoning about the layout of an array in memory<a class="headerlink" href="#reasoning-about-the-layout-of-an-array-in-memory" title="Permalink to this headline">¶</a></h2>
<p>The C++ standard defines the <a class="reference external" href="http://eel.is/c++draft/dcl.array#6">layout of arrays</a> as follows:</p>
<blockquote class="pull-quote">
<div><p>An object of type “array of N U” contains a contiguously allocated non-empty set of N subobjects of type U, known as the elements of the array, and numbered 0 to N-1.</p>
</div></blockquote>
<p>This means that there is no padding between elements of an array.</p>
<div class="section" id="id4">
<h3>How is this reflected in BRiCk?<a class="headerlink" href="#id4" title="Permalink to this headline">¶</a></h3>
</div>
</div>
<div class="section" id="reasoning-about-the-layout-of-a-union-in-memory">
<h2>Reasoning about the layout of a union in memory<a class="headerlink" href="#reasoning-about-the-layout-of-a-union-in-memory" title="Permalink to this headline">¶</a></h2>
<p>The C++ standard defines the <a class="reference external" href="http://eel.is/c++draft/class.union#3">layout of unions</a> as follows:</p>
<blockquote class="pull-quote">
<div><p>The size of a union is sufficient to contain the largest of its
non-static data members. Each non-static data member is allocated
as if it were the sole member of a non-union class. [Note: A union
object and its non-static data members are pointer-interconvertible
([basic.compound], [expr.static.cast]). As a consequence, all
non-static data members of a union object have the same address. —
end note]</p>
</div></blockquote>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>All members sharing the same address does not mean that the same
pointer is valid to access all of them. In particular, accessing
the member that is not the active member of a union is UB. This is currently
the source of a <a class="reference external" href="https://gitlab.com/bedrocksystems/cpp2v-core/-/issues/101">soundness bug in cpp2v</a>.</p>
</div>
<div class="section" id="how-is-this-reflected-in-cpp2v">
<h3>How is this reflected in cpp2v?<a class="headerlink" href="#how-is-this-reflected-in-cpp2v" title="Permalink to this headline">¶</a></h3>
<p>cpp2v does not reflect that all members of the same union have the same address.
<a class="reference external" href="https://gitlab.com/bedrocksystems/cpp2v-core/-/blob/232541a3a7410ac585908a35c50583007c3a391c/theories/lang/cpp/logic/layout.v#L61">Axiom decompose_union</a> uses <code class="code highlight coq docutils literal notranslate"><span class="o"><span class="pre">_</span></span><span class="n"><span class="pre">field</span></span></code> that in turn uses <code class="code highlight coq docutils literal notranslate"><span class="n"><span class="pre">offset_of</span></span></code> that uses opaque offset information from the translation unit.</p>
<p><strong>Potential solution</strong>: Allow the user to assume some facts about the offset information in the translation unit.</p>
</div>
</div>
<div class="section" id="working-with-the-low-level-representation-of-objects">
<h2>Working with the low-level representation of objects<a class="headerlink" href="#working-with-the-low-level-representation-of-objects" title="Permalink to this headline">¶</a></h2>
<p>Consider the following code that does not exhibit undefined behavior (can be checked using <a class="reference external" href="https://cerberus.cl.cam.ac.uk/cerberus">Cerberus</a>):</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="cpf">&lt;stddef.h&gt;</span><span class="cp"></span>

<span class="k">struct</span> <span class="n">S</span> <span class="p">{</span>
  <span class="kt">short</span> <span class="n">a</span><span class="p">;</span>
  <span class="c1">// The compiler must insert padding here to satisfy the alignment requirement of b</span>
  <span class="kt">int</span> <span class="n">b</span><span class="p">;</span>
<span class="p">};</span>

<span class="kt">void</span> <span class="nf">custom_memcpy</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">dest</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">src</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
   <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">d</span> <span class="o">=</span> <span class="n">dest</span><span class="p">,</span> <span class="o">*</span><span class="n">s</span> <span class="o">=</span> <span class="n">src</span><span class="p">;</span>
   <span class="k">for</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
     <span class="o">*</span><span class="n">d</span> <span class="o">=</span> <span class="o">*</span><span class="n">s</span><span class="p">;</span>
     <span class="n">d</span><span class="o">++</span><span class="p">;</span> <span class="n">s</span><span class="o">++</span><span class="p">;</span>
   <span class="p">}</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">struct</span> <span class="n">S</span> <span class="n">s1</span><span class="p">,</span> <span class="n">s2</span><span class="p">;</span>
  <span class="n">s1</span><span class="p">.</span><span class="n">a</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">s1</span><span class="p">.</span><span class="n">b</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span> <span class="c1">// Create an object using its high-level representation</span>
  <span class="n">custom_memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s2</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">s1</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">S</span><span class="p">));</span> <span class="c1">// Copy the low-level representation of the object (including padding)</span>
  <span class="n">assert</span><span class="p">(</span><span class="n">s2</span><span class="p">.</span><span class="n">b</span> <span class="o">==</span> <span class="mi">2</span><span class="p">);</span> <span class="c1">// Access the resulting memory via the high-level representation</span>
<span class="p">}</span>
</pre></div>
</div>
<p>This code is interesting because it accesses both the high-level representation and low-level representation of an object.
In particular, there are parts of memory that are not accessible via the high-level representation (the padding of <code class="code highlight cpp docutils literal notranslate"><span class="k"><span class="pre">struct</span></span> <span class="n"><span class="pre">S</span></span></code>), but that are accessible via the low-level representation.</p>
<div class="section" id="id5">
<h3>How is this reflected in BRiCk?<a class="headerlink" href="#id5" title="Permalink to this headline">¶</a></h3>
<p>BRiCk provides access to the low-level view of data via the <code class="code highlight coq docutils literal notranslate"><span class="n"><span class="pre">Vraw</span></span> <span class="n"><span class="pre">r</span></span></code> value where <code class="code highlight coq docutils literal notranslate"><span class="n"><span class="pre">r</span></span></code> represents a “raw byte”. cpp2v is parametric in this notion of raw byte, but a simple model would instantiate it with <code class="code highlight coq docutils literal notranslate"><span class="n"><span class="pre">byte</span></span> <span class="o"><span class="pre">|</span></span> <span class="n"><span class="pre">pointer</span></span> <span class="n"><span class="pre">fragment</span></span> <span class="o"><span class="pre">|</span></span> <span class="n"><span class="pre">poison</span></span></code> (i.e. <code class="code highlight coq docutils literal notranslate"><span class="n"><span class="pre">runtime_val</span></span></code> in <code class="code highlight coq docutils literal notranslate"><span class="n"><span class="pre">simple_pred</span></span></code>).    <a class="reference external" href="https://gitlab.com/bedrocksystems/cpp2v-core/-/blob/master/theories/lang/cpp/logic/layout.v">layout.v</a> provides axioms for converting between the high-level representation (e.g. <code class="code highlight coq docutils literal notranslate"><span class="n"><span class="pre">primR</span></span></code>) and the low-level representation based on <code class="code highlight coq docutils literal notranslate"><span class="n"><span class="pre">Vraw</span></span></code>.</p>
<p>Thus, the example above can be verified by first converting the struct to raw bytes, copying the raw bytes and then converting the raw bytes back into the struct.</p>
</div>
</div>
<div class="section" id="representing-values">
<h2>Representing Values<a class="headerlink" href="#representing-values" title="Permalink to this headline">¶</a></h2>
<p>In the BRiCk separation logic, we choose to immediately materialize all aggregates (i.e. aggregates do not have a Coq-value representation), and address the delayed materialization through the fact that not all pointers (<a class="reference external" href="_static/coqdoc/bedrock.lang.cpp.semantics.ptrs.html#ptr">ptr</a>) are required to be backed by memory.</p>
<div class="section" id="pinned-pointers">
<h3>Pinned Pointers<a class="headerlink" href="#pinned-pointers" title="Permalink to this headline">¶</a></h3>
<p>In certain instances, especially when communicating pointers with assembly, it is necessary to connect pointers to the virtual addresses.
To do this, BRiCk exposes a separation logic assertion <code class="code highlight coq docutils literal notranslate"><span class="n"><span class="pre">pinned_ptr</span></span> <span class="o"><span class="pre">:</span></span> <span class="n"><span class="pre">ptr</span></span> <span class="o"><span class="pre">-&gt;</span></span> <span class="n"><span class="pre">vaddr</span></span> <span class="o"><span class="pre">-&gt;</span></span> <span class="n"><span class="pre">mpred</span></span></code> (<a class="reference external" href="_static/coqdoc/bedrock.lang.cpp.logic.pred.html#pinned_ptr">pinned_ptr</a>) that connects the <code class="code highlight coq docutils literal notranslate"><span class="n"><span class="pre">ptr</span></span></code> to the virtual address that backs it.</p>
</div>
<div class="section" id="function-call-semantics">
<h3>Function Call Semantics<a class="headerlink" href="#function-call-semantics" title="Permalink to this headline">¶</a></h3>
<p>Following options:</p>
<p><strong>Pass as everything as values</strong>: (as e.g. in RefinedC)</p>
<ul class="simple">
<li><p>Both primitives and aggregates are passed as values to and from functions</p></li>
<li><p>Callee allocates space to put the values</p></li>
<li><p>Con: Needs representation of structures as values (works in C, but more tricky in C++)</p></li>
</ul>
<p><strong>Pass as everything via locations</strong>: (as e.g. in Cerberus)</p>
<ul class="simple">
<li><p>Both primitives and aggregates are passed via locations to and from functions</p></li>
<li><p>Caller allocates locations, stores values there and then passes them to the function</p></li>
<li><p>Pro: Aggregates only need to be represented in locations, never as values</p></li>
<li><p>Con: Since primitives are passed via the heap, the specification cannot directly destruct them</p></li>
</ul>
<p><strong>Pass primitives as values and aggregates via locations</strong>: (as currently in cpp2v)</p>
<ul class="simple">
<li><p>Primitives are passed as values and aggregates via locations</p></li>
<li><p>Pro: Primitives can be directly destructed in specifications</p></li>
<li><p>Con: Probably break templates because an instantiation with a primitive value would produce quite different code than an instantiatation with an aggregate value</p></li>
</ul>
<p class="rubric">Footnotes</p>
<dl class="footnote brackets">
<dt class="label" id="krebbers-thesis-2-5"><span class="brackets"><a class="fn-backref" href="#id2">1</a></span></dt>
<dd><p>Section 2.5 of <a class="reference external" href="https://robbertkrebbers.nl/research/thesis.pdf">Robbert Krebbers - The C standard formalized in Coq</a></p>
</dd>
<dt class="label" id="abi-arm"><span class="brackets"><a class="fn-backref" href="#id3">2</a></span></dt>
<dd><p><a class="reference external" href="https://developer.arm.com/documentation/ihi0042/latest?_ga=2.60211309.1506853196.1533541889-405231439.1528186050">Procedure Call Standard for the Arm Architecture</a></p>
</dd>
</dl>
</div>
</div>
</div>


           </div>
           
          </div>
          <footer>
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
        <a href="machine.html" class="btn btn-neutral float-right" title="Assembly Interoperation" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
        <a href="pointers.html" class="btn btn-neutral float-left" title="Pointers and pointer provenance" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>
        &#169; Copyright 2021 BedRock Systems.

    </p>
  </div>
    
    
    
    Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>
        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>